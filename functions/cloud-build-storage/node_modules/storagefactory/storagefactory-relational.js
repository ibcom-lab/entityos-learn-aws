/*
	Factory for STORAGE FACTORY.
	ie build model with system data on Aurora Service 

	//lab-rds-cluster-001-aurora-serverless-v2.cluster-ctqe76w42vxr.ap-southeast-2.rds.amazonaws.com

*/

var entityos = require('entityos');
var _ = require('lodash')
var moment = require('moment');

module.exports = 
{
	VERSION: '0.0.1',

	init: function (param)
	{
		entityos.add(
		[
			{
				name: 'storage-relational-data-store-get-connection',
				code: function (param)
				{
					const settings = entityos.get({scope: '_settings'});
					const event = entityos.get({scope: '_event'});
					const storage = _.get(event, 'storage');

					let storageConnection = 
					{
						host: _.get(storage, 'instance.url'),
						port: _.get(storage, 'cluster.port'),
						user: _.get(storage, 'cluster.user'),         // Aurora master user
						password: _.get(storage, 'cluster.password'),
						database: _.get(storage, 'database.name')
					}

					if (storageConnection.host == undefined)
					{
						storageConnection.host = _.get(settings, 'build.storage.default.instance.url')
					}

					if (storageConnection.port == undefined)
					{
						storageConnection.port = _.get(settings, 'build.storage.default.cluster.port', 3306)
					}

					if (storageConnection.user == undefined)
					{
						storageConnection.user = _.get(settings, 'build.storage.default.cluster.user', 'admin')
					}

					if (storageConnection.password == undefined)
					{
						storageConnection.password = _.get(settings, 'build.storage.default.cluster.password')
					}

					return storageConnection;
				}
			},
			{
				name: 'storage-relational-data-base-create',
				code: function (param)
				{
					const settings = entityos.get({scope: '_settings'});
					const event = entityos.get({scope: '_event'});

					const storage = _.get(event, 'storage');

					let storageConnection = 
					{
						host: _.get(storage, 'instance.url'),
						port: _.get(storage, 'cluster.port'),
						user: _.get(storage, 'cluster.user'),         // Aurora master user
						password: _.get(storage, 'cluster.password')
					}

					if (storageConnection.host == undefined)
					{
						storageConnection.host = _.get(settings, 'build.storage.default.instance.url')
					}

					if (storageConnection.port == undefined)
					{
						storageConnection.port = _.get(settings, 'build.storage.default.cluster.port', 3306)
					}

					if (storageConnection.user == undefined)
					{
						storageConnection.user = _.get(settings, 'build.storage.default.cluster.user', 'admin')
					}

					if (storageConnection.password == undefined)
					{
						storageConnection.password = _.get(settings, 'build.storage.default.cluster.password')
					}

					const mysql = require('mysql2/promise');

					mysql.createConnection(storageConnection)
					.then(function (connection)
					{
						let storageName = _.get(storage, 'name');
						storageName = _.replace(storageName, /-/g, '_');

						return connection.execute('CREATE DATABASE IF NOT EXISTS ' + storageName)
						.then(function ()
						{
							console.log('Database ' + storageName + ' created or already exists.');
							connection.end();
							entityos.invoke('util-end',
							{
								method: 'storage-relational-data-create',
								datastoragename: storageName
							})
						})
						.catch(function (err)
						{
							console.error('Error creating database:', err.message);
							connection.end();
							entityos.invoke('util-end', {data: {method: 'storage-relational-data-base-create', error: err}})
						});
					})
					.catch(function (err)
					{
						console.error('Error connecting to database:', err.message);
					});
				}
			},
			{
				name: 'model-relational-data-util-convert-type',
				code: function (column)
				{
					var event = entityos.get({scope: '_event'});
					const dataStoreEngine = _.get(event, 'storage.database.engine', 'mssql');

					const baseType = column.typetext.toLowerCase();
					if (baseType === 'varchar')
					{
						if (dataStoreEngine === 'mssql') return 'VARCHAR(255)' + (column.collationname ? ' COLLATE ' + column.collationname : '');
						if (dataStoreEngine === 'mysql') return 'VARCHAR(255)' + (column.collationname ? ' CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci' : '');
					}

					if (baseType === 'int') return 'INT';
					if (baseType === 'datetime') return dataStoreEngine === 'mysql' ? 'DATETIME(3)' : 'DATETIME';

					return baseType.toUpperCase();
				}
			},
			{
				name: 'model-relational-data-util-convert-identity',
				code: function (column)
				{
					var event = entityos.get({scope: '_event'});
					const dataStoreEngine = _.get(event, 'storage.database.engine', 'mssql');

					const identity = (column.isidentity == 'true' ? (
								dataStoreEngine == 'mssql' ? ' IDENTITY(1,1)' : ' AUTO_INCREMENT'
							) : '');

					return identity;
				}
			},
			{
				name: 'model-relational-data-util-create-table',
				code: function (modelObjectDefinition)
				{
					var event = entityos.get({scope: '_event'});

					const identityCol = _.find(modelObjectDefinition.columns, function(c) {return c.isidentity == 'true'});

					const createSQL = [];

					const dataStoreEngine = _.get(event, 'storage.database.engine', 'mssql');

					_.each(modelObjectDefinition.columns, function (column, c)
					{
						//console.log(column)
						
						let baseType = column.typetext.toLowerCase();
						if (baseType == 'varchar')
						{
							if (dataStoreEngine === 'mssql') {baseType = 'VARCHAR(' + column.length + ')' + (column.collationname ? ' COLLATE ' + column.collationname : '')};
							if (dataStoreEngine === 'mysql') {baseType = 'VARCHAR(' + column.length + ')' + (column.collationname ? ' CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci' : '')};
						}

						if (baseType == 'char')
						{
							baseType = 'CHAR(' + column.length + ')'
						}
						if (baseType == 'int')  {basetype = 'INT'};
						if (baseType == 'datetime') basetype = (dataStoreEngine === 'mysql' ? 'DATETIME(3)' : 'DATETIME');

						if (baseType == 'money' && dataStoreEngine == 'mysql')
						{
							baseType = 'DECIMAL(10,2)'
						}

						if (baseType == 'decimal' )
						{
							baseType = 'DECIMAL(' + column.precision + ',' + column.scale + ')'
						}

						let type = baseType.toUpperCase();

						let nullable = (column.isnullable == 'true' ? 'NULL' : 'NOT NULL');

						let identity = (column.isidentity == 'true' ? (
								dataStoreEngine == 'mssql' ? ' IDENTITY(1,1)' : ' PRIMARY KEY AUTO_INCREMENT'
							) : '');

						if (identity)
						{
							nullable = 'NOT NULL';
						}
						
						if (dataStoreEngine == 'mysql')
						{
							column.name = '`' + column.name + '`';
						}
						
						const _createSQL = ' ' + column.name + ' ' + type + identity + ' ' + nullable;

						if (identity)
						{
							createSQL.unshift( _createSQL);
						}
						else
						{
							createSQL.push(_createSQL);
						}
					});

					//createSQL.unshift('CREATE TABLE ' + modelObjectDefinition.name + ' (');
					//createSQL.push(');');

					const createSQLStatement = 'CREATE TABLE ' + modelObjectDefinition.name + ' (\n' 
							+ createSQL.join(',\n')
							+ '\n);'

					return createSQLStatement;
				}
			},
			{
				name: 'model-relational-data-util-update-table',
				code: function (modelObjectDefinition)
				{
					var event = entityos.get({scope: '_event'});

					let updateSQLStatement;
					let columns = modelObjectDefinition.columns;

					const columnsFilter = _.get(event, 'storage.model.update.columns.filter');

					if (columnsFilter == 'isnullable')
					{
						columns = _.filter(columns, function (column)
						{
							return column.isnullable == 'true';
						});
					}

					if (columns.length != 0)
					{
						const identityCol = _.find(modelObjectDefinition.columns, function(c) {return c.isidentity == 'true'});

						const updateSQL = [];

						updateSQL.push('ALTER TABLE ' + modelObjectDefinition.name);

						const dataStoreEngine = _.get(event, 'storage.database.engine', 'mssql');

						_.each(columns, function (column, c)
						{
							//console.log(column)
							
							let baseType = column.typetext.toLowerCase();
							if (baseType == 'varchar')
							{
								if (dataStoreEngine === 'mssql') {baseType = 'VARCHAR(' + column.length + ')' + (column.collationname ? ' COLLATE ' + column.collationname : '')};
								if (dataStoreEngine === 'mysql') {baseType = 'VARCHAR(' + column.length + ')' + (column.collationname ? ' CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci' : '')};
							}

							if (baseType == 'char')
							{
								baseType = 'CHAR(' + column.length + ')'
							}
							if (baseType == 'int')  {basetype = 'INT'};
							if (baseType == 'datetime') basetype = (dataStoreEngine === 'mysql' ? 'DATETIME(3)' : 'DATETIME');

							if (baseType == 'money' && dataStoreEngine == 'mysql')
							{
								baseType = 'DECIMAL(10,2)'
							}

							let type = baseType.toUpperCase();

							let nullable = (column.isnullable == 'true' ? 'NULL' : 'NOT NULL');

							let identity = (column.isidentity == 'true' ? (
									dataStoreEngine == 'mssql' ? ' IDENTITY(1,1)' : ' PRIMARY KEY AUTO_INCREMENT'
								) : '');
							
							if (identity)
							{
								nullable = 'NOT NULL';
							}

							if (dataStoreEngine == 'mysql')
							{
								column.name = '`' + column.name + '`';
							}

							if (column._action == undefined)
							{
								column._action = 'MODIFY';
							}
							
							const _updateSQL = column._action + ' ' + column.name + ' ' + type + identity + ' ' + nullable;

							updateSQL.push((c == modelObjectDefinition.columns.length - 1 ? _updateSQL : _updateSQL + ','));
						});

						updateSQL.push(';');

						updateSQLStatement = updateSQL.join('\n');
					}

					return updateSQLStatement;
				}
			},
			{
				name: 'storage-relational-data-model-create',
				code: function (param)
				{
					const settings = entityos.get({scope: '_settings'});
					var event = entityos.get({scope: '_event'});

					let _dataModel;

					const modelFolder = _.get(settings, 'build.storage.folder', 'storage/schema/model');
					const filenameModel = _.get(event, 'storage.model.filename');

					if (filenameModel != undefined)
					{
						const fs = require('fs');
						const dataModel = fs.readFileSync(modelFolder + '/' + filenameModel, 'utf8');
						
						if (dataModel != undefined)
						{
							_dataModel = JSON.parse(dataModel);
						}

						//console.log(_dataModel)
					}

					const modelObjectName = _.get(event, 'storage.model.object.name');

					if (modelObjectName != undefined)
					{
						_dataModel = _.filter(_dataModel, function (modelObject)
						{
							return (modelObject.name == modelObjectName)
						})
					}

					const processStart = _.get(event, 'storage.model.process.start', 0);
					const processEnd = _.get(event, 'storage.model.process.end', _dataModel.length);

					_dataModel = _dataModel.slice(processStart, processEnd);

					entityos.set(
					{
						scope: 'storage-relational-data-model-create',
						context: 'model-objects',
						value: _dataModel
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-create',
						context: 'model-objects-index',
						value: 0
					});

					//console.log(_dataModel)
					entityos.invoke('storage-relational-data-model-create-process');
				}
			},
			{
				name: 'storage-relational-data-model-create-process',
				code: function (param)
				{
					var event = entityos.get({scope: '_event'});

					var dataModelObjects = entityos.get(
					{
						scope: 'storage-relational-data-model-create',
						context: 'model-objects'
					});

					var dataModelObjectsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-create',
						context: 'model-objects-index',
						value: 0
					});

					if (dataModelObjectsIndex == dataModelObjects.length)
					{
						entityos.invoke('storage-relational-data-model-create-finalise');
					}
					else
					{
						let modelObjectDefinition = dataModelObjects[dataModelObjectsIndex];

						const createSQLStatement = entityos.invoke('model-relational-data-util-create-table', modelObjectDefinition);

						const simulate = _.get(event, 'storage.simulate', false);

						if (simulate || createSQLStatement == undefined)
						{
							console.log(createSQLStatement);
							entityos.invoke('storage-relational-data-model-create-next');
						}
						else
						{

							const storageConnection = entityos.invoke('storage-relational-data-store-get-connection');

							//console.log(storageConnection);

							console.log(createSQLStatement)

							const mysql = require('mysql2/promise');

							mysql.createConnection(storageConnection)
							.then(function (connection)
							{
								return connection.execute(createSQLStatement)
								.then(function ()
								{
									console.log('Table ' + modelObjectDefinition.name + ' created.');
									connection.end();
									entityos.invoke('storage-relational-data-model-create-next');
								})
								.catch(function (err)
								{
									console.error('Error creating table:', err.message);
									connection.end();
									//entityos.invoke('util-end', {method: 'storage-relational-data-model-create', error: err})
									entityos.invoke('storage-relational-data-model-create-next');
								});
							})
							.catch(function (err)
							{
								entityos.invoke('util-end',
								{
									method: 'storage-relational-data-model-create',
									error: 'Error connecting to database: ' + err.message
								})
							});
						}
					}
				}
			},
			{
				name: 'storage-relational-data-model-create-next',
				code: function (param)
				{
					let dataModelObjectsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-create',
						context: 'model-objects-index',
						value: 0
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-create',
						context: 'model-objects-index',
						value: (dataModelObjectsIndex + 1)
					});

					entityos.invoke('storage-relational-data-model-create-process');
				}
			},
			{
				name: 'storage-relational-data-model-create-finalise',
				code: function (param)
				{
					const dataModelObjectsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-create',
						context: 'model-objects-index',
						value: 0
					});

					entityos.invoke('util-end',
					{
						method: 'storage-relational-data-model-create',
						datastorageobjectscreated: (dataModelObjectsIndex)
					});
				}
			},
			{
				name: 'storage-relational-data-model-update',
				code: function (param)
				{
					const settings = entityos.get({scope: '_settings'});
					var event = entityos.get({scope: '_event'});
					const filenameModel = _.get(event, 'storage.model.filename');

					let _dataModel;

					_dataModel = _.get(event, 'storage.model.update.objects');

					if (_dataModel == undefined && filenameModel != undefined)
					{
						const modelFolder = _.get(settings, 'build.storage.folder', 'storage/schema/model');
						
						const fs = require('fs');
						const dataModel = fs.readFileSync(modelFolder + '/' + filenameModel, 'utf8');
						
						if (dataModel != undefined)
						{
							_dataModel = JSON.parse(dataModel);
						}

						//console.log(_dataModel)
					}

					const modelObjectName = _.get(event, 'storage.model.object.name');

					if (modelObjectName != undefined)
					{
						_dataModel = _.filter(_dataModel, function (modelObject)
						{
							return (modelObject.name == modelObjectName)
						})
					}

					const processStart = _.get(event, 'storage.model.process.start', 0);
					const processEnd = _.get(event, 'storage.model.process.end', _dataModel.length);

					_dataModel = _dataModel.slice(processStart, processEnd);

					entityos.set(
					{
						scope: 'storage-relational-data-model-update',
						context: 'model-objects',
						value: _dataModel
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-update',
						context: 'model-objects-index',
						value: 0
					});

					//console.log(_dataModel)
					entityos.invoke('storage-relational-data-model-update-process');
				}
			},
			{
				name: 'storage-relational-data-model-update-process',
				code: function (param)
				{
					var event = entityos.get({scope: '_event'});

					var errors = [];

					var dataModelObjects = entityos.get(
					{
						scope: 'storage-relational-data-model-update',
						context: 'model-objects'
					});

					var dataModelObjectsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-update',
						context: 'model-objects-index',
						value: 0
					});

					if (dataModelObjectsIndex == dataModelObjects.length)
					{
						entityos.invoke('storage-relational-data-model-update-finalise');
					}
					else
					{
						let modelObject = dataModelObjects[dataModelObjectsIndex];

						const updateSQLStatement = entityos.invoke('model-relational-data-util-update-table', modelObject);

						const simulate = _.get(event, 'storage.simulate', false);

						if (simulate || updateSQLStatement == undefined)
						{
							console.log(updateSQLStatement);
							entityos.invoke('storage-relational-data-model-update-next');
						}
						else
						{
							const storageConnection = entityos.invoke('storage-relational-data-store-get-connection');
							const mysql = require('mysql2/promise');

							mysql.createConnection(storageConnection)
							.then(function (connection)
							{
								console.log(updateSQLStatement);

								return connection.execute(updateSQLStatement)
								.then(function (msg)
								{
									console.log('Table ' + modelObject.name + ' updated.');
									console.log(msg);
									connection.end();
									entityos.invoke('storage-relational-data-model-update-next');
								})
								.catch(function (err)
								{
									modelObject.error = err;
									//console.error('Error creating table:', err.message);
									connection.end();
									//entityos.invoke('util-end', {method: 'storage-relational-data-model-create', error: err})
									entityos.invoke('storage-relational-data-model-update-next');
								});
							})
							.catch(function (err)
							{
								entityos.invoke('util-end',
								{
									method: 'storage-relational-data-model-update',
									error: 'Error connecting to database: ' + err.message
								})
							});
						}
					}
				}
			},
			{
				name: 'storage-relational-data-model-update-next',
				code: function (param)
				{
					let dataModelObjectsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-update',
						context: 'model-objects-index',
						value: 0
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-update',
						context: 'model-objects-index',
						value: (dataModelObjectsIndex + 1)
					});

					entityos.invoke('storage-relational-data-model-update-process');
				}
			},
			{
				name: 'storage-relational-data-model-update-finalise',
				code: function (param)
				{
					const dataModelObjectsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-update',
						context: 'model-objects-index',
						value: 0
					});

					var dataModelObjects = entityos.get(
					{
						scope: 'storage-relational-data-model-update',
						context: 'model-objects'
					});

					entityos.invoke('util-end',
					{
						method: 'storage-relational-data-model-update',
						data: {
							datastorageobjectsupdated: (dataModelObjectsIndex),
							errors: _.get(dataModelObjects, function (object) {return object.error != undefined})
						}
					});
				}
			},
			{
				name: 'storage-relational-data-execute',
				code: function (param)
				{
					const settings = entityos.get({scope: '_settings'});
					var event = entityos.get({scope: '_event'});

					const executeSQL = _.get(event, 'storage.execute.sql');

					if (executeSQL == undefined)
					{
						entityos.invoke('util-end', {method: 'storage-relational-data-execute', error: 'No SQL to execute.'})
					}
					else
					{
						let validSQL = true;

						if (_.includes(executeSQL.toLowerCase(), 'drop'))
						{
							validSQL = false;

							const instanceID =  _.get(event, 'storage.instance.id');

							console.log(instanceID)
							console.log(_.startsWith(instanceID, 'lab'))

							if (_.startsWith(instanceID, 'lab'))
							{
								validSQL = true;
							}
						}
					
						if (!validSQL)
						{
							entityos.invoke('util-end', {method: 'storage-relational-data-execute', error: 'Not a Valid SQL on non-lab instance.'})
						}
						else
						{
							const storageConnection = entityos.invoke('storage-relational-data-store-get-connection');

							const mysql = require('mysql2/promise');

							mysql.createConnection(storageConnection)
							.then(function (connection)
							{
								return connection.execute(executeSQL)
								.then(function (response)
								{
									console.log('Executed.');
									connection.end();
									entityos.invoke('util-end',
									{
										method: 'storage-relational-data-execute',
										data: {response: response}
									})
								})
								.catch(function (err)
								{
									//console.error('Error:', err.message);
									connection.end();
									entityos.invoke('util-end', {data: {method: 'storage-relational-data-execute', error: err}});
								});
							})
							.catch(function (err)
							{
								console.error('Error connecting to database:', err.message);
							});
						}
					}
				}
			},
			{
				name: 'storage-relational-data-query',
				code: function (param)
				{
					const settings = entityos.get({scope: '_settings'});
					var event = entityos.get({scope: '_event'});

					const querySQL = _.get(event, 'storage.query.sql');

					if (querySQL == undefined)
					{
						entityos.invoke('util-end', {method: 'storage-relational-data-query', error: 'No SQL to query with.'})
					}
					else
					{
						if (!_.startsWith('lab', _.get(event, 'storage.instance.id')) &&
								_.includes(querySQL.toLowerCase(), 'drop'))
						{
							entityos.invoke('util-end', {method: 'storage-relational-data-query', error: 'Not a Valid SQL on non-lab instance.'})
						}
						else
						{
							//console.log(querySQL)

							const storageConnection = entityos.invoke('storage-relational-data-store-get-connection');

							const mysql = require('mysql2/promise');

							mysql.createConnection(storageConnection)
							.then(function (connection)
							{
								return connection.query(querySQL)
								.then(function (rows)
								{
									connection.end();
									entityos.invoke('util-end',
									{
										method: 'storage-relational-data-query',
										data: {rows: _.first(rows)}
									})
								})
								.catch(function (err)
								{
									console.error('Error:', err.message);
									connection.end();
									entityos.invoke('util-end', {data: {method: 'storage-relational-data-query', error: err}})
								});
							})
							.catch(function (err)
							{
								console.error('Error connecting to database:', err.message);
							});
						}
					}
				}
			}
		]);

		//-- MODEL INFORMATION

		entityos.add(
		[
			{
				name: 'storage-relational-data-model-information',
				code: function (param)
				{
					entityos.invoke('storage-relational-data-model-information-process');
				}
			},
			{
				name: 'storage-relational-data-model-information-process',
				code: function (param)
				{
					const settings = entityos.get({scope: '_settings'});
					var event = entityos.get({scope: '_event'});

					//const informationSQLStatement = 'SHOW TABLES';

					const databaseName = _.get(event, 'storage.database.name')

					var informationSQLStatement = 
						'SELECT table_name, table_rows' +
						' FROM information_schema.tables' +
						' WHERE table_schema = \'' + databaseName + '\'';

					const tableName = _.get(event, 'storage.information.table.name');

					if (tableName != undefined)
					{
						informationSQLStatement +=
							' AND table_name = \'' + tableName + '\'';
					}

					console.log(informationSQLStatement);

					const storageConnection = entityos.invoke('storage-relational-data-store-get-connection');

					console.log(storageConnection);

					const mysql = require('mysql2/promise');

					mysql.createConnection(storageConnection)
					.then(function (connection)
					{
						return connection.query(informationSQLStatement)
						.then(function (rows)
						{
							//console.log(rows);
							connection.end();
							//sql: informationSQLStatement,
							entityos.invoke('util-end',
							{
								method: 'storage-relational-data-model-information',
								rows: rows[0]
							});
						})
						.catch(function (err)
						{
							//console.error('Error creating table:', err.message);
							connection.end();
							entityos.invoke('util-end', {data: {method: 'storage-relational-data-model-informatio', error: err}})
						});
					})
					.catch(function (err)
					{
						entityos.invoke('util-end',
						{
							method: 'sstorage-relational-data-model-informatio',
							error: 'Error connecting to database: ' + err.message
						});
					});
				}
			}
		]);

		//-- INITIALISE MODEL (GENESIS DATA)

		entityos.add(
		{
			name: 'storage-relational-data-model-initialise-genesis',
			notes: 'Create the SQL for each of the genesis objects that allow the compute instance to active the entity (object) interface.',
			code: function (param)
			{
				entityos.invoke('storage-relational-data-model-initialise-genesis-check');
			}
		});

		//- CHECK

		entityos.add(
		[
			{
				name: 'storage-relational-data-model-initialise-genesis-check',
				notes: 'Check if the genesis objects exist in storage - so do not recreate.',
				code: function (param)
				{
					const settings = entityos.get({scope: '_settings'});
					var event = entityos.get({scope: '_event'});

					const genesisObjects = _.get(event, 'storage.initialise.genesis.objects');

					let initialiseObjects = _.filter(genesisObjects, function (genesisObject)
					{
						return (_.get(genesisObject, 'data.fields') != undefined)
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects',
						value: initialiseObjects
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects-index',
						value: 0
					});

					entityos.invoke('storage-relational-data-model-initialise-genesis-check-process')
				}
			},
			{
				name: 'storage-relational-data-model-initialise-genesis-check-process',
				code: function (param)
				{
					const settings = entityos.get({scope: '_settings'});
					var event = entityos.get({scope: '_event'});

					var dataModelObjects = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects'
					});

					var dataModelObjectsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects-index',
						value: 0
					});

					if (dataModelObjectsIndex == dataModelObjects.length)
					{
						entityos.invoke('storage-relational-data-model-initialise-genesis-check-finalise');
					}
					else
					{
						let dataModelObject = dataModelObjects[dataModelObjectsIndex];

						const databaseName = _.get(event, 'storage.database.name')
						const tableName = dataModelObject.name;

						var checkSQLStatement = 
							'SELECT table_name, table_rows' +
								' FROM information_schema.tables' +
								' WHERE table_schema = \'' + databaseName + '\'' +
								' AND table_name = \'' + tableName + '\'';

						console.log(checkSQLStatement);

						const storageConnection = entityos.invoke('storage-relational-data-store-get-connection');

						//console.log(storageConnection);

						const simulate = _.get(event, 'storage.simulate', false);

						if (simulate)
						{
							dataModelObject.rowsCount = 0;
							entityos.invoke('storage-relational-data-model-initialise-genesis-check-next', modelObjectDefinition.rowsCount);
						}
						else
						{
							const mysql = require('mysql2/promise');
							mysql.createConnection(storageConnection)
							.then(function (connection)
							{
								return connection.execute(checkSQLStatement)
								.then(function (rows)
								{
									const row = rows[0];
									dataModelObject._row = row;
									dataModelObject.rowsCount = _.get(row, 'table_rows', 0);

									//console.log(modelObjectDefinition.name)
									//console.log(row);
									connection.end();

									entityos.set(
									{
										scope: 'storage-relational-data-model-initialise-genesis',
										context: 'model-objects',
										value: dataModelObjects
									});

									entityos.invoke('storage-relational-data-model-initialise-genesis-check-next', dataModelObject.rowsCount);
								})
								.catch(function (err)
								{
									connection.end();
									entityos.invoke('storage-relational-data-model-initialise-genesis-check-next');
								});
							})
							.catch(function (err)
							{
								entityos.invoke('util-end',
								{
									method: 'storage-relational-data-model-initialise-genesis-check',
									error: 'Error connecting to database: ' + err.message
								})
							});
						}
					}
				}
			},
			{
				name: 'storage-relational-data-model-initialise-genesis-check-next',
				code: function (param)
				{
					let dataModelObjectsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects-index',
						value: 0
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects-index',
						value: (dataModelObjectsIndex + 1)
					});

					entityos.invoke('storage-relational-data-model-initialise-genesis-check-process');
				}
			},
			{
				name: 'storage-relational-data-model-initialise-genesis-check-finalise',
				code: function (param)
				{
					//entityos.invoke('storage-relational-data-model-initialise-genesis-create');

					var dataModelObjects = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects'
					});

					var event = entityos.get({scope: '_event'});

					if (event.method == 'storage-relational-data-model-initialise-genesis-check')
					{
						entityos.invoke('util-end',
						{
							method: 'storage-relational-data-model-initialise-genesis-check',
							genesisobjects: dataModelObjects
						});
					}
					else
					{
						entityos.invoke('storage-relational-data-model-initialise-genesis-create');
					}
				}
			}
		])	

		//- SQL
		
		entityos.add(
		[
			{
				name: 'storage-relational-data-model-initialise-genesis-create',
				notes: 'Create the SQL for each of the genesis objects that allow the compute instance to active the entity (object) interface.',
				code: function (param)
				{
					const settings = entityos.get({scope: '_settings'});
					var event = entityos.get({scope: '_event'});

					var _dataModelObjects;

					const modelFolder = _.get(settings, 'storage.model.folder', 'schema/model');
					const modelFilename = _.get(event, 'storage.model.filename');

					if (modelFilename != undefined)
					{
						const fs = require('fs');
						const dataModelObjects = fs.readFileSync(modelFolder + '/' + modelFilename, 'utf8');
						
						if (dataModelObjects != undefined)
						{
							_dataModelObjects = JSON.parse(dataModelObjects);
						}

						//console.log(_dataModelObjects)
					}

					var genesisObjects = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects'
					});

					let initialiseObjects = _.filter(genesisObjects, function (genesisObject)
					{
						return (_.get(genesisObject, 'rowsCount') == 0)
					});

					_.each(initialiseObjects, function (object)
					{
						object._definition = _.find(_dataModelObjects, function (_dataModelObject)
						{	
							return _dataModelObject.name == object.name
						});
					});

					//console.log(initialiseObjects);

					_.each(initialiseObjects, function (initialiseObject)
					{
						const initialiseObjectFields = _.get(initialiseObject, 'data.fields');
						const initialiseModelObjectDefinitionColumns = _.get(initialiseObject, '_definition.columns');
					
						if (initialiseObjectFields != undefined)
						{
							let initialiseSQL = [];

							initialiseSQL.push('INSERT INTO ' + initialiseObject.name);

							initialiseSQL.push('(');

							//Only for objects where data supplied. i.e. event.initalise.objects

							let initialiseSQLFieldNames = [];
							let initialiseSQLFieldValues = [];

							_.each(initialiseObjectFields, function (field)
							{
								field.name = field.name.toLowerCase();

								initialiseSQLFieldNames.push(field.name);

								if (field.value == '{{guid}}')
								{
									const { randomUUID } = require('crypto');
									field.value = randomUUID();
								}

								if (field.value == '{{now}}')
								{
									field.value = moment().format('YYYY-MM-DD HH:mm:ss')
								}

								if (field.value == '{{null}}')
								{
									field.value = 'NULL'
								}
								else
								{
									//map to check if integer based on _definition

									//console.log(initialiseModelObjectDefinitionColumns)

									const fieldDefinition = _.find(initialiseModelObjectDefinitionColumns, function (column)
									{
										return column.name.toLowerCase() == field.name;
									});

									if (fieldDefinition == undefined)
									{
										console.log('!! Can not find definition for ' + field.name + ' / ' + initialiseObject.name + '.')
									}
									else
									{
										if (fieldDefinition.typetext == 'char'
												|| fieldDefinition.typetext == 'varchar'
												|| fieldDefinition.typetext == 'date'
												|| fieldDefinition.typetext == 'datetime'
												|| fieldDefinition.typetext == 'text')
										{
											field.value = '\'' + field.value + '\'';
										}
									}
								}

								initialiseSQLFieldValues.push(field.value);
							});

							initialiseSQL.push(_.join(initialiseSQLFieldNames, ','));
							initialiseSQL.push(') VALUES (' );
							initialiseSQL.push(_.join(initialiseSQLFieldValues, ','));
							initialiseSQL.push(')');

							initialiseObject.sql = initialiseSQL.join(' ');

							//console.log(initialiseObjects.sql);
						}
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects',
						value: initialiseObjects
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects-index',
						value: 0
					});
					
					entityos.invoke('storage-relational-data-model-initialise-genesis-process')
				}
			},
			{
				name: 'storage-relational-data-model-initialise-genesis-process',
				code: function (param)
				{
					const settings = entityos.get({scope: '_settings'});
					var event = entityos.get({scope: '_event'});

					var dataModelObjects = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects'
					});

					var dataModelObjectsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects-index',
						value: 0
					});

					if (dataModelObjectsIndex == dataModelObjects.length)
					{
						entityos.invoke('storage-relational-data-model-initialise-genesis-finalise');
					}
					else
					{
						let dataModelObject = dataModelObjects[dataModelObjectsIndex];

						const createSQLStatement = dataModelObject.sql;

						const simulate = _.get(event, 'storage.simulate', false)

						if (simulate)
						{
							console.log(createSQLStatement);
							entityos.invoke('storage-relational-data-model-initialise-genesis-next');
						}
						else
						{
							const storageConnection = entityos.invoke('storage-relational-data-store-get-connection');

							//console.log(storageConnection);

							const mysql = require('mysql2/promise');

							mysql.createConnection(storageConnection)
							.then(function (connection)
							{
								return connection.execute(createSQLStatement)
								.then(function ()
								{
									console.log('Table ' + dataModelObject.name + ' genenis initialised.');
									connection.end();
									entityos.invoke('storage-relational-data-model-initialise-genesis-next');
								})
								.catch(function (error)
								{
									dataModelObject.error = error;
									connection.end();
									entityos.invoke('storage-relational-data-model-initialise-genesis-next');
								});
							})
							.catch(function (err)
							{
								entityos.invoke('util-end',
								{
									method: 'storage-relational-data-model-initialise-genesis-process',
									data: {error: 'Error connecting to database: ' + err.message}
								})
							});
						}
					}
				}
			},
			{
				name: 'storage-relational-data-model-initialise-genesis-next',
				code: function (param)
				{
					var dataModelObjectsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects-index',
						value: 0
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects-index',
						value: (dataModelObjectsIndex + 1)
					});

					entityos.invoke('storage-relational-data-model-initialise-genesis-process');
				}
			},
			{
				name: 'storage-relational-data-model-initialise-genesis-finalise',
				code: function (param)
				{
					var event = entityos.get({scope: '_event'});

					const dataModelObjectsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects-index',
						value: 0
					});

					const simulate = _.get(event, 'storage.simulate', false);

					let returnData = {
						method: 'storage-relational-data-model-initialise-genesis',
						datastorageobjectsinitialised: (dataModelObjectsIndex)
					}

					const dataModelObjects = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-genesis',
						context: 'model-objects'
					});

					if (simulate)
					{
						returnData.sqls = _.map(dataModelObjects, 'sql');
					}
					else
					{
						returnData.errors = _.map(dataModelObjects, 'error');
					}

					entityos.invoke('util-end', returnData);
				}
			}
		])
		
		//-- INITIALISE MODEL (NON-GENESIS DATA)
			//-- STARTING WITH TYPE:SYSTEM (ID:3)
			//-- https://www.entityos.io/models/

		// FUNCTIONS ARE GENERIC - DEFAULT TO "System"

		entityos.add(
		[
			{
				name: 'storage-relational-data-model-initialise-data',
				notes: 'Create the data insert SQL for each of the objects required as part of the model.',
				code: function (param)
				{
					// If no event.data.filenames then get every filename on the folder
					// 	and put into event.data.filenames[]

					// Then in -init get the model so know the data field types

					// Then in -process go through each of the events.data.filenames[]
					//	- open the the file
					//  - get the data and create the insert statements - like -genesis

					const settings = entityos.get({scope: '_settings'});
					var event = entityos.get({scope: '_event'});

					const processStartIndex = _.get(event, 'storage.process.startindex', 0);

					//console.log(processStartIndex);

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'process-index',
						value: processStartIndex
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'processed-index',
						value: 0
					});

					const modelDataFolder = _.get(event, 'storage.initialise.data.folder', 'data/system');
					const modelDataFilenames = _.get(event, 'storage.initialise.data.filenames');

					if (modelDataFilenames == undefined)
					{
						const fs = require('fs').promises;
						const path = require('path');

						fs.readdir(modelDataFolder, { withFileTypes: true })
						.then(function (entries)
						{
							const _entries = entries
							.filter(e => e.isFile())
							.map(e => e.name)
							.filter(name => name.toLowerCase().endsWith('.json'))
							
							return _entries
						})
						.then(function(filenames)
						{
							_.set(event, 'storage.initialise.data.filenames', filenames);
							entityos.invoke('storage-relational-data-model-initialise-data-init')
						})
						.catch(console.error);
					}
					else
					{
						entityos.invoke('storage-relational-data-model-initialise-data-init');
					}
				}
			},
			{
				name: 'storage-relational-data-model-initialise-data-init',
				code: function (param)
				{
					var event = entityos.get({scope: '_event'});
					const modelDataFilenames = _.get(event, 'storage.initialise.data.filenames');

					//console.log(modelDataFilenames);

					const processStartIndex = _.get(event, 'storage.process.startindex', 0);

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'process',
						value: modelDataFilenames
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'process-index',
						value: processStartIndex
					});

					// Get model file for working out the inserts later

					const fs = require('fs');

					const modelFolder = _.get(event, 'storage.model.folder', 'schema/model');
					const modelFilename = _.get(event, 'storage.model.filename');

					const dataModelObjects = fs.readFileSync(modelFolder + '/' + modelFilename, 'utf8');

					if (dataModelObjects != undefined)
					{
						_dataModelObjects = JSON.parse(dataModelObjects);
					}

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'model',
						value: _dataModelObjects
					});

					entityos.invoke('storage-relational-data-model-initialise-data-process')
				}
			},
			{
				name: 'storage-relational-data-model-initialise-data-process',
				code: function (param)
				{
					var event = entityos.get({scope: '_event'});
					const modelDataFilenames = _.get(event, 'storage.initialise.data.filenames');
					const dataStoreEngine = _.get(event, 'storage.database.engine', 'mssql');

					console.log(modelDataFilenames);

					const storageObjectsToProcess = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'process'
					});

					const storageObjectsToProcessIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'process-index'
					});

					const storageObjectsProcessedIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'processed-index',
						valueDefault: 0
					});

					const storageModelObjects = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'model'
					});

					const processMaximum = _.get(event, 'storage.process.maximum', 10);

					console.log(storageObjectsToProcessIndex, ' (', storageObjectsProcessedIndex, '/', processMaximum, ')');
					console.log('/', storageObjectsToProcess.length, ' (total)')

					if (storageObjectsToProcessIndex < storageObjectsToProcess.length && storageObjectsProcessedIndex < processMaximum)
					{
						const modelDataFolder = _.get(event, 'storage.initialise.data.folder', 'data/system');
						const modelDataFileName = storageObjectsToProcess[storageObjectsToProcessIndex];

						const fs = require('fs');
						const modelDataObject = fs.readFileSync(modelDataFolder + '/' + modelDataFileName, 'utf8');
						const _modelDataObject = JSON.parse(modelDataObject);
						
						//console.log(_modelDataObject);

						_modelDataObject._model = _.find(storageModelObjects, function (_storageModelObject)
						{
							return (_storageModelObject.name == _modelDataObject.object.name)
						});

						//console.log(_modelDataObject._model)

						// Need the model to know what type it is 

						_modelDataObject.initialiseSQL = [];
						//_modelDataObject.initialiseSQLSelect = [];

						if (_modelDataObject.data != undefined)
						{
							//Only for for where data supplied. i.e. event.initalise.objects
							// Need to get data from entityos-model

							if (false && dataStoreEngine === 'mssql')
							{
								_modelDataObject.initialiseSQLInsert.push(
								{
									object: _modelDataObject.object.name,
									sql: {system: 'SET IDENTITY_INSERT ' + _.toUpper(_modelDataObject.object.name) + ' ON;'}
								});
							}
							
							_.each(_modelDataObject.data, function (_data)
							{
								// SELECT - FOR CHECKING

								let initialiseSQLSelect = [];

								initialiseSQLSelect.push('SELECT * FROM ' + _modelDataObject.object.name);

								const [key, value] = Object.entries(_data)[0];
								
								initialiseSQLSelect.push('WHERE ' + key + ' = ' + value + ';')
								
								/*_modelDataObject.initialiseSQLSelect.push(
								{
									object: _modelDataObject.object.name,
									key: key, 
									sql: initialiseSQLSelect.join(' ')
								});*/

								//console.log(_modelDataObject.initialiseSQLSelect)
									
								// INSERT

								let initialiseSQL = [];

								initialiseSQL.push('INSERT INTO ' + _modelDataObject.object.name);

								initialiseSQL.push('(');

								let initialiseSQLFieldNames = [];
								let initialiseSQLFieldValues = [];

								_.each(_data, function (value, key)
								{
									initialiseSQLFieldNames.push(key)
									//console.log(key)

									let _value = value;

									const keyModel = _.find(_modelDataObject._model.columns, function (column)
									{
										return (key == column.name)
									});

									//console.log(keyModel)

									// _value format based keyModel

									if (keyModel.typetext == 'char'
											|| keyModel.typetext == 'varchar'
											|| keyModel.typetext == 'text')
									{
										_value = '\'' + _value + '\'';
									}

									initialiseSQLFieldValues.push(_value)
								});

								initialiseSQL.push(_.join(initialiseSQLFieldNames, ', '));
								initialiseSQL.push(') VALUES (' );
								initialiseSQL.push(_.join(initialiseSQLFieldValues, ', '));
								initialiseSQL.push(');');

								_modelDataObject.initialiseSQL.push(
								{
									object: _modelDataObject.object.name,
									key: key,
									keyValue: value,
									sql:
									{
										select: initialiseSQLSelect.join(' '),
										insert: initialiseSQL.join(' ')
									}
								});

								if (false && dataStoreEngine === 'mssql')
								{
									_modelDataObject.initialiseSQL.push(
									{
										object: _modelDataObject.object.name,
										sql:
										{
											system: 'SET IDENTITY_INSERT ' + _.toUpper(_modelDataObject.object.name) + ' OFF;'
										}
									})
								}
							
								//console.log(_modelDataObject.initialiseSQL);
							});

							entityos.set(
							{
								scope: 'storage-relational-data-model-initialise-data',
								context: 'processing-object',
								value: _modelDataObject
							});

							entityos.set(
							{
								scope: 'storage-relational-data-model-initialise-data',
								context: 'processing-object-sqls-index-selects',
								value: 0
							});

							entityos.invoke('storage-relational-data-model-initialise-data-check');

							//console.log(initialiseModelObjects);
						}
					}
					else
					{
						entityos.invoke('storage-relational-data-model-initialise-data-finalise');
					}

				}
			},
			{
				name: 'storage-relational-data-model-initialise-data-check',
				notes: 'Go through the selects and see if returns rows',
				code: function (param)
				{
					var event = entityos.get({scope: '_event'});

					var initialiseDataObject = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'processing-object'
					});

					//console.log(initialiseDataObject);

					var initialiseDataObjectInitialiseSQLs = initialiseDataObject.initialiseSQL

					var initialiseDataObjectInitialiseSQLsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'processing-object-sqls-index-selects',
						valueDefault: 0
					});

					if (initialiseDataObjectInitialiseSQLsIndex == initialiseDataObjectInitialiseSQLs.length)
					{
						entityos.invoke('storage-relational-data-model-initialise-data-sql-process');
					}
					else
					{
						let _initialiseDataObjectInitialiseSQL = initialiseDataObjectInitialiseSQLs[initialiseDataObjectInitialiseSQLsIndex];

						console.log(initialiseDataObjectInitialiseSQLsIndex)
						//console.log(_initialiseDataObjectInitialiseSQL)
						let initialiseSQLSelect = _initialiseDataObjectInitialiseSQL.sql.select;

						console.log(initialiseSQLSelect);

						//const createSQLStatement = entityos.invoke('model-relational-data-util-create-table', modelObjectDefinition);

						//console.log(createSQLStatement);

						const simulate = _.get(event, 'storage.simulate', false);

						if (simulate)
						{
							_initialiseDataObjectInitialiseSQL.rowsCount = 0;
							entityos.invoke('storage-relational-data-model-initialise-data-check-next', _initialiseDataObjectInitialiseSQL.rowsCount);
						}
						else
						{
							const storageConnection = entityos.invoke('storage-relational-data-store-get-connection');

							//console.log(storageConnection);

							const mysql = require('mysql2/promise');

							mysql.createConnection(storageConnection)
							.then(function (connection)
							{
								return connection.query(initialiseSQLSelect)
								.then(function (rows)
								{
									console.log(rows);
									const row = rows[0];
									_initialiseDataObjectInitialiseSQL._row = row;
									_initialiseDataObjectInitialiseSQL.rowsCount = _.get(row, 'table_rows', 0);

									connection.end();
									entityos.invoke('storage-relational-data-model-initialise-data-check-next', _initialiseDataObjectInitialiseSQL.rowsCount);
								})
								.catch(function (err)
								{
									console.error(err.message);
									connection.end();
									//entityos.invoke('util-end', {method: 'storage-relational-data-model-create', error: err})
									entityos.invoke('storage-relational-data-model-initialise-data-check-next');
								});
							})
							.catch(function (err)
							{
								entityos.invoke('util-end',
								{
									method: 'storage-relational-data-model-initialise-data-check',
									error: 'Error connecting to database: ' + err.message
								})
							});
						}
					}
				}
			},
			{
				name: 'storage-relational-data-model-initialise-data-check-next',
				code: function (param)
				{
					let initialiseSQLSelectsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'processing-object-sqls-index-selects',
						value: 0
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'processing-object-sqls-index-selects',
						value: (initialiseSQLSelectsIndex + 1)
					});

					entityos.invoke('storage-relational-data-model-initialise-data-check');
				}
			},
			{
				name: 'storage-relational-data-model-initialise-data-sql-process',
				notes: 'Go through the selects and see if returns rows',
				code: function (param)
				{
					var event = entityos.get({scope: '_event'});

					var initialiseDataObject = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'processing-object'
					});

					//console.log(initialiseDataObject);

					var initialiseDataObjectInitialiseSQLs = initialiseDataObject.initialiseSQL

					// Go through each initialiseDataObjectInitialiseSQLs and execute the insert where rowsCount == 0

					//console.log(initialiseDataObjectInitialiseSQLsIndex);

					var initialiseDataObjectInitialiseSQLsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-data-sql',
						context: 'processing-object-sqls-index-inserts',
						valueDefault: 0
					});

					//console.log('initialiseDataObjectInitialiseSQLs:');
					//console.log(initialiseDataObjectInitialiseSQLs)

					console.log(initialiseDataObjectInitialiseSQLsIndex)

					if (initialiseDataObjectInitialiseSQLsIndex == initialiseDataObjectInitialiseSQLs.length)
					{
						entityos.set(
						{
							scope: 'storage-relational-data-model-initialise-data-sql',
							context: 'processing-object-sqls-index-inserts',
							value: 0
						});
						
						entityos.invoke('storage-relational-data-model-initialise-data-next');
					}
					else
					{
						let _initialiseDataObjectInitialiseSQL = initialiseDataObjectInitialiseSQLs[initialiseDataObjectInitialiseSQLsIndex];

						// Check rowsCount == 0

						//console.log(_initialiseDataObjectInitialiseSQL)

						if (_initialiseDataObjectInitialiseSQL.rowsCount != 0)
						{
							entityos.invoke('storage-relational-data-model-initialise-data-sql-next');
						}
						else
						{
							let initialiseSQLInsert = _initialiseDataObjectInitialiseSQL.sql.insert;

							console.log(initialiseSQLInsert);

							//console.log(initialiseSQLInsert);

							const simulate = _.get(event, 'storage.simulate', false);

							if (simulate)
							{
								_initialiseDataObjectInitialiseSQL.rowsCount = 1; // inserted
								entityos.invoke('storage-relational-data-model-initialise-data-sql-next', _initialiseDataObjectInitialiseSQL.rowsCount);
							}
							else
							{
								const storageConnection = entityos.invoke('storage-relational-data-store-get-connection');

								//console.log(storageConnection);

								//console.log(initialiseSQLInsert)

								const mysql = require('mysql2/promise');

								mysql.createConnection(storageConnection)
								.then(function (connection)
								{
									return connection.execute(initialiseSQLInsert)
									.then(function (msg)
									{
										console.log(msg);
										_initialiseDataObjectInitialiseSQL.msg = msg;
										_initialiseDataObjectInitialiseSQL.rowsCount = 1;
										connection.end();
										entityos.invoke('storage-relational-data-model-initialise-data-sql-next', _initialiseDataObjectInitialiseSQL.rowsCount);
									})
									.catch(function (err)
									{
										console.error('Error:', err.message);
										_initialiseDataObjectInitialiseSQL.msg = err.message;
										connection.end();
										//entityos.invoke('util-end', {method: 'storage-relational-data-model-create', error: err})
										entityos.invoke('storage-relational-data-model-initialise-data-sql-next');
									});
								})
								.catch(function (err)
								{
									entityos.invoke('util-end',
									{
										method: 'storage-relational-data-model-initialise-data-sql',
										error: 'Error connecting to database: ' + err.message
									})
								});
							}
						}
					}
				}
			},
			{
				name: 'storage-relational-data-model-initialise-data-sql-next',
				code: function (param)
				{
					let initialiseSQLInsertsIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-data-sql',
						context: 'processing-object-sqls-index-inserts',
						value: 0
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-data-sql',
						context: 'processing-object-sqls-index-inserts',
						value: (initialiseSQLInsertsIndex + 1)
					});

					entityos.invoke('storage-relational-data-model-initialise-data-sql-process');
				}
			},
			{
				name: 'storage-relational-data-model-initialise-data-sql-finalise',
				code: function (param)
				{
					var event = entityos.get({scope: '_event'});
					const check = _.get(event, 'storage.initialise.processing', true);

					if (check)
					{
						var initialiseDataObject = entityos.get(
						{
							scope: 'storage-relational-data-model-initialise-data',
							context: 'processing-object'
						});

						const folder = _.get(event, 'storage.initialise.processed', 'data/processed');
						const filename = folder + '/entityos-storage-data-objects-' + _.get(initialiseDataObject, 'object.id') + '-' + _.get(initialiseDataObject, 'object.name') + '-processed.json'

						entityos.invoke('util-save-to-file',
						{
							filename: filename,
							fileData: initialiseDataObject,
							onComplete: 'storage-relational-data-model-initialise-data-complete'
						});
					}
					else
					{
						entityos.invoke('storage-relational-data-model-initialise-data-complete');
					}
				}
			},
			{
				name: 'storage-relational-data-model-initialise-data-next',
				code: function (param)
				{
					let storageObjectsToProcessIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'process-index'
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'process-index',
						value: (storageObjectsToProcessIndex + 1)
					});

					let storageObjectsProcessedIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'processed-index'
					});

					entityos.set(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'processed-index',
						value: (storageObjectsProcessedIndex + 1)
					});

				
					entityos.invoke('storage-relational-data-model-initialise-data-process');
				}
			},
			{
				name: 'storage-relational-data-model-initialise-data-finalise',
				code: function (param)
				{
					entityos.invoke('storage-relational-data-model-initialise-data-complete');	
				}
			},
			{
				name: 'storage-relational-data-model-initialise-data-complete',
				code: function (param)
				{
					let storageObjectsProcessedIndex = entityos.get(
					{
						scope: 'storage-relational-data-model-initialise-data',
						context: 'processed-index'
					});

					entityos.invoke('util-end',
					{
						method: 'storage-relational-data-model-initialise-data',
						storageobjectsprocessed: (storageObjectsProcessedIndex)
					});	
				}
			}
		])


		entityos.add(
		{
			name: 'storage-relational-util-encrypt',
			notes: 'Encrypt the user (sec_person) password for use with genesis methods',
			code: function (param)
			{
				/**
				 * AES Encrypter Legacy (Plain JS version)
				 * Ported from VB.NET AesEncrypterLegacy
				 * --------------------------------------
				 * AES-256-CBC with PBKDF2/SHA1 (1000 iterations)
				 * Text + encryptSalt are UTF-16LE ("Unicode" in VB)
				 * Derivation order matches Rfc2898DeriveBytes:
				 *   IV first, then Key
				 */

				var event = entityos.get({scope: '_event'});

				const crypto = require('crypto');

				// ====== INPUT CONSTANTS ======
				const encryptBusinessID = _.get(event, 'encrypt.business.id');   // 0 if no business-based key
				const encryptBaseKey = _.get(event, 'encrypt.key.base'); // mimic Registry BaseKey
				let encryptSalt = _.get(event, 'encrypt.user.guid'); // is sec_person.guid
				if (encryptSalt == undefined)
				{
					encryptSalt = _.get(event, 'encrypt.Salt'); 
				}
				const encryptText = _.get(event, 'encrypt.text');          // text to encrypt/decrypt
				// optional GUID for BusinessId > 0
				const encryptBusinessGUID =  _.get(event, 'encrypt.business.guid'); // is sec_business.guid

				// =======================================

				const MIN_SAFE_ASCII = 32;
				const MAX_SAFE_ASCII = 126;

				/**
				 * Derive secret key depending on BusinessId / GUID
				 */

				function deriveSecretKey(businessId, baseKey, guid)
				{
					if (!baseKey) throw new Error('Base Encryption Key not set');

					if (!businessId || businessId == 0)
					{
						// same as VB "if miBusinessId = 0 then msSecretKey = sBaseKey"
						return baseKey;
					}

					if (!guid) throw new Error('Could not encrypt data (blank GUID)');

					let limit = Math.min(baseKey.length, guid.length);
					let out = '';

					for (let i = 0; i < limit; i++)
					{
						let iChar = guid.charCodeAt(i) + baseKey.charCodeAt(i);
						if (iChar > MAX_SAFE_ASCII)
						{
							iChar = (iChar % (MAX_SAFE_ASCII - MIN_SAFE_ASCII)) + MIN_SAFE_ASCII;
						}
						out += String.fromCharCode(iChar);
					}

					return out;
				}

				/**
				 * Derive AES key/IV from secretKey + encryptSalt (UTF-16LE), same order as .NET
				 */

				function deriveAlgorithm(secretKey, encryptSalt)
				{
					const KEY_SIZE_BITS = 256;
					const BLOCK_SIZE_BYTES = 16;
					const KEY_BYTES = KEY_SIZE_BITS / 8;

					const encryptSaltBytes = Buffer.from(encryptSalt, 'utf16le');
					const secretBytes = Buffer.from(secretKey, 'utf16le');

					// total bytes = IV + Key
					const derived = crypto.pbkdf2Sync(secretBytes, encryptSaltBytes, 1000, BLOCK_SIZE_BYTES + KEY_BYTES, 'sha1');

					const iv = derived.subarray(0, BLOCK_SIZE_BYTES);
					const key = derived.subarray(BLOCK_SIZE_BYTES, BLOCK_SIZE_BYTES + KEY_BYTES);

					return { key, iv };
				}

				/**
				 * Encrypt encryptText using AES-256-CBC (same as RijndaelManaged)
				 */

				function encrypt(encryptText, secretKey, encryptSalt)
				{
					const { key, iv } = deriveAlgorithm(secretKey, encryptSalt);
					const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);

					const plainBuf = Buffer.from(encryptText, 'utf16le');
					const encrypted = Buffer.concat([cipher.update(plainBuf), cipher.final()]);

					return encrypted.toString('base64');
				}

				/**
				 * Decrypt ciphertext using AES-256-CBC
				 */

				function decrypt(encryptedText, secretKey, encryptSalt)
				{
					const { key, iv } = deriveAlgorithm(secretKey, encryptSalt);
					const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);

					const input = Buffer.from(encryptedText, 'base64');
					const decrypted = Buffer.concat([decipher.update(input), decipher.final()]);

					return decrypted.toString('utf16le');
				}

				// ====== MAIN FLOW ======
				try
				{
					const secretKey = deriveSecretKey(encryptBusinessID, encryptBaseKey, encryptBusinessGUID);

					console.log('Secret Key:', secretKey);

					const encrypted = encrypt(encryptText, secretKey, encryptSalt);
					console.log('\nEncrypted (Base64):', encrypted);

					const decrypted = decrypt(encrypted, secretKey, encryptSalt);
					console.log('\nDecrypted (UTF-16LE):', decrypted);
				}
				catch (err)
				{
					console.error('\nError:', err.message);
				}
			}
		});
	}
}