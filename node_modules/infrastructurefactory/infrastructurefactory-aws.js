/*
	Factory for AWS Infrastructure
*/

var entityos = require('entityos')
var _ = require('lodash')
var moment = require('moment');

module.exports = 
{
	VERSION: '0.0.1',

	init: function (param)
	{
		entityos.add(
		{
			name: 'util-aws-get-config',
			code: function ()
			{
				const settings = entityos.get({scope: '_settings'});
				const event = entityos.get({scope: '_event'});

				let accessID = _.get(settings, 'infrastructure.aws.access.id');
				let accessSecretKey = _.get(settings, 'infrastructure.aws.access.secret');

				if (accessID == 'prompt' || accessSecretKey == 'prompt')
				{
					const prompt = require('prompt-sync')();

					if (accessID == 'prompt')
					{
						const _accessID = prompt('AWS Access ID: ');
						_.set(settings, 'infrastructure.aws.access.id', _accessID);
					}

					if (accessSecretKey == 'prompt')
					{
						const _accessSecretKey = prompt('AWS Access Secret Key: ');
						_.set(settings, 'infrastructure.aws.access.secret', _accessSecretKey);
					}
				}

				process.env.AWS_ACCESS_KEY_ID = _.get(settings, 'infrastructure.aws.access.id');
				process.env.AWS_SECRET_ACCESS_KEY =  _.get(settings, 'infrastructure.aws.access.secret');

				const infrastructureConfig = 
				{
					credentials:
					{
						accessKeyId: _.get(settings, 'infrastructure.aws.access.id'),
						secretAccessKey: _.get(settings, 'infrastructure.aws.access.secret')
					},
					region: 'ap-southeast-2'
				}

				return infrastructureConfig;
			}
		});
		
		//--- EC2

		entityos.add(
		{
			name: 'util-aws-ec2-instances',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const instanceIDs = _.get(event, 'instance.ids');

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
				
				const { EC2Client, DescribeInstancesCommand } = require("@aws-sdk/client-ec2");

				const ec2 = new EC2Client(infrastructureConfig);

				let commandParams = {};

				if (instanceIDs != undefined)
				{
					commandParams.InstanceIds = instanceIDs
				}

				const command = new DescribeInstancesCommand(commandParams);

				ec2.send(command).then(function(response)
					{
						const instances = response.Reservations?.flatMap((reservation) =>
							reservation.Instances?.map((instance) => ({
								instanceId: instance.InstanceId,
								state: instance.State.Name,
								instanceType: instance.InstanceType,
								publicIpAddress: instance.PublicIpAddress,
								subnetId: instance.SubnetId,
								tags: instance.Tags
							}))
						);

						_.each(instances, function (instance)
						{
							instance.tagName = _.find(instance.tags, function (tag)
							{
								return tag.Key == 'Name'
							});

							instance.name = _.get(instance.tagName, 'Value', '')
						});

						console.table(instances)

						_.each(response.Reservations, function (reservation)
						{
							console.log(reservation.Instances);
						});

						entityos.set(
						{
							scope: 'ec2',
							context: 'instances',
							value: instances
						});

						params.instances = instances;
						entityos._util.onComplete(params)		
					}
				);	
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-instances',
			code: function ()
			{
				entityos.invoke('util-aws-ec2-instances',
				{
					onComplete: 'app-process-aws-ec2-instances-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-instances-process',
			code: function (params)
			{
				let responseData =
				{
					instances: _.get(params, 'instances', {})
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-instances-change-state',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const instanceIDs = _.get(event, 'instance.ids');

				const status = _.get(event, 'status');

				if (status == undefined || instanceIDs == undefined)
				{
					entityos.invoke('util-end', 'No status or instanceIDs set', '200');
				}
				else
				{
					let commandParams = {};

					if (instanceIDs != undefined)
					{
						commandParams.InstanceIds = instanceIDs
					}

					const infrastructureConfig = entityos.invoke('util-aws-get-config');
				
					const { EC2Client, StartInstancesCommand, StopInstancesCommand } = require("@aws-sdk/client-ec2");

					const ec2 = new EC2Client(infrastructureConfig);

					let command;
					
					if (status == 'start')
					{
						command = new StartInstancesCommand(commandParams);
					}

					if (status == 'stop')
					{
						command = new StopInstancesCommand(commandParams);
					}

					ec2.send(command).then(function(response)
						{
							let responseData = response;
							delete responseData['$metadata'];

							entityos.invoke('util-end', responseData, '200');
						}
					);	
				}
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-instance-create',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const createParams = _.get(event, 'create');

				if (createParams == undefined)
				{
					entityos.invoke('util-end', 'No create params set', '200');
				}
				else
				{
					let commandParams = {};

					const tagName = _.get(createParams, 'tag.namePrefix') + '-' +  _.get(createParams, 'tag.nameIndexStart')

					commandParams = _.assign(commandParams,
					{
						ImageId: _.get(createParams, 'image.id'),
						InstanceType: _.get(createParams, 'instance.type'),
						MinCount: 1,
						MaxCount: _.get(createParams, 'instance.count'),
						KeyName: _.get(createParams, 'keyName'),
						SecurityGroupIds: _.get(createParams, 'securityGroupIDs'),
						SubnetId: _.get(createParams, 'subnetID'),
						TagSpecifications: [
						{
							ResourceType: "instance",
							Tags: [
								{ Key: "Name", Value: tagName }
							],
						}]
					});

					if (createParams.awsOptions)
					{
						commandParams = _.assign(commandParams, createParams.awsOptions)
					}

					if (instanceIDs != undefined)
					{
						commandParams.InstanceIds = instanceIDs
					}

					const infrastructureConfig = entityos.invoke('util-aws-get-config');
				
					const { EC2Client, RunInstancesCommand } = require("@aws-sdk/client-ec2");

					const ec2 = new EC2Client(infrastructureConfig);

					let command;
					
					command = new RunInstancesCommand(commandParams);
					
					ec2.send(command).then(function(response)
						{
							let responseData = response;
							delete responseData['$metadata'];

							entityos.invoke('util-end', responseData, '200');
						}
					);	
				}
			}
		});

		entityos.add(
		{
			name: 'util-aws-ec2-subnets',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const subnetIDs = _.get(event, 'subnet.ids');

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
				
				const { EC2Client, DescribeSubnetsCommand } = require("@aws-sdk/client-ec2");

				const ec2 = new EC2Client(infrastructureConfig);

				let commandParams = {};

				if (subnetIDs != undefined)
				{
					commandParams.SubnetIDs = subnetIDs
				}

				const command = new DescribeSubnetsCommand(commandParams);

				ec2.send(command).then(function(response)
					{
						console.log(response.Subnets)
						const subnets = response.Subnets?.map((subnet) => ({
								subnetId: subnet.SubnetId,
								vpcId: subnet.VpcId,
								availabilityZone: subnet.AvailabilityZone,
								availabilityZoneId: subnet.AvailabilityZoneId,
								defaultForAz: subnet.DefaultForAz,
								cidrBlock: subnet.CidrBlock,
								state: subnet.State,
								arn: subnet.SubnetArn,
								blockPublicAccessStates: subnet.BlockPublicAccessStates,
								tags: subnet.Tags
							}));
					
						_.each(subnets, function (subnet)
						{
							subnet.tagName = _.find(subnet.tags, function (tag)
							{
								return tag.Key == 'Name'
							});

							subnet.name = _.get(subnet.tagName, 'Value', '')
						});

						console.table(subnets)

						entityos.set(
						{
							scope: 'ec2',
							context: 'subnets',
							value: subnets
						});

						params.subnets = subnets;
						entityos._util.onComplete(params)		
					}
				);	
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-subnets',
			code: function ()
			{
				entityos.invoke('util-aws-ec2-subnets',
				{
					onComplete: 'app-process-aws-ec2-subnets-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-subnets-process',
			code: function (params)
			{
				let responseData =
				{
					subnets: _.get(params, 'subnets', {})
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		//-- MACHINE IMAGES

		entityos.add(
		{
			name: 'util-aws-ec2-instance-images',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const instanceID = _.get(event, 'instance.id');

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
		
				const { EC2Client, DescribeImagesCommand } = require("@aws-sdk/client-ec2");

				const ec2 = new EC2Client(infrastructureConfig);

				let commandParams =
				{
					Owners: ["self"]
				};

				if (instanceID != undefined)
				{
					commandParams.Filters =
					[
						{
							Name: "name",
							Values: ["image-" + instanceID + "-*"]
						}
					]	
				}

				const command = new DescribeImagesCommand(commandParams);

				ec2.send(command).then(function(response)
					{
						let instanceImages = response.Images?.map((image) => ({
							imageId: image.ImageId,
							name: image.Name,
							state: image.State,
							sourceInstanceId: image.SourceInstanceId,
							deregistrationProtection: image.DeregistrationProtection,
							creationDate: image.CreationDate
						}));

						console.table(instanceImages)

						instanceImages = _.sortBy(instanceImages, (image) => {
							return -moment(image.creationDate).valueOf();
						});

						entityos.set(
						{
							scope: 'ec2',
							context: 'instanceImages',
							value: instanceImages
						});

						params.instanceImages = instanceImages;
						entityos._util.onComplete(params)		
					}
				);
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-instance-images',
			code: function ()
			{
				entityos.invoke('util-aws-ec2-instance-images',
				{
					onComplete: 'app-process-aws-ec2-instance-images-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-instance-images-process',
			code: function (params)
			{
				let responseData =
				{
					instanceImages: _.get(params, 'instanceImages')
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-instance-image-delete-oldest',
			code: function ()
			{
				entityos.invoke('util-aws-ec2-instance-images',
				{
					onComplete: 'app-process-aws-ec2-instance-image-delete-oldest-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-instance-image-delete-oldest-process',
			code: function (params)
			{
				let instanceImages = _.get(params, 'instanceImages', []);

				if (instanceImages.length > 1)
				{
					const event = entityos.get({scope: '_event'});
					const instanceImageOlderThanHours = parseInt(_.get(event, 'image.olderThanHours', 48));

					const currentDate = moment();

					instanceImages = instanceImages.filter((image) => {
						const creationDate = moment(image.creationDate);
						return currentDate.diff(creationDate, 'hours') >= instanceImageOlderThanHours;
					});

					instanceImages = _.sortBy(instanceImages, (image) => {
						return -moment(image.creationDate).valueOf();
					});

					const instanceImageToDelete = _.last(instanceImages);

					if (instanceImageToDelete != undefined)
					{
						entityos.invoke('util-aws-ec2-instance-image-delete',
						{
							imageID: instanceImageToDelete.imageId
						});
					}
					else
					{
						entityos.invoke('util-end', 'No instance images older than ' + instanceImageOlderThanHours + ' hours.', '200');
					}
				}
				else
				{
					entityos.invoke('util-end', 'No instance images', '200');
				}
			}
		});

		entityos.add(
		{
			name: 'util-aws-ec2-instance-image-delete',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});
				const settings = entityos.get({scope: '_settings'});

				const settingsDeleteKey = _.get(settings, 'infrastructure.aws.keys.delete');
				const eventDeleteKey = _.get(event, 'deletekey');

				if (settingsDeleteKey != eventDeleteKey)
				{
					entityos.invoke('util-end', 'DeleteKey not valid.', '200');
				}
				else
				{
					let imageID = _.get(param, 'imageID');

					if (imageID == undefined)
					{
						imageID = _.get(event, 'image.id');
					}

					if (imageID == undefined)
					{
						entityos.invoke('util-end', 'No image.id set', '200');
					}
					else
					{
						let commandParams =
						{
							ImageId: imageID
						}

						const infrastructureConfig = entityos.invoke('util-aws-get-config');
					
						const { EC2Client, DeregisterImageCommand } = require("@aws-sdk/client-ec2");
						const ec2 = new EC2Client(infrastructureConfig);

						const command = new DeregisterImageCommand(commandParams);

						ec2.send(command).then(function(response)
							{
								let responseData = response;
								delete responseData['$metadata'];

								entityos.invoke('util-end', responseData, '200');
							}
						);
					}
				}
			}
		});

		entityos.add(
		{
			name: 'util-aws-ec2-instance-image-create',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const instanceID = _.get(event, 'instance.id');

				let instanceImageName = _.get(event, 'image.name');
				let instanceImageDescription = _.get(event, 'image.description', '');
			
				if (instanceID == undefined)
				{
					entityos.invoke('util-end', 'No instanceID set', '200');
				}
				else
				{
					if (instanceImageName == undefined)
					{
						instanceImageName = 'image-' + instanceID + '-' + moment().format('YYYY-MM-DD-HH-mm').toUpperCase()
					}

					let commandParams =
					{
						InstanceId: instanceID,
						Name: instanceImageName,
						Description: instanceImageDescription,
						NoReboot: true
					};

					const infrastructureConfig = entityos.invoke('util-aws-get-config');
				
					const { EC2Client, CreateImageCommand } = require("@aws-sdk/client-ec2");

					const ec2 = new EC2Client(infrastructureConfig);

					let command = new CreateImageCommand(commandParams);
				
					ec2.send(command).then(function(response)
						{
							let instanceImage = response;
							delete instanceImage['$metadata'];
							
							entityos.set(
							{
								scope: 'ec2',
								context: 'instanceImage',
								value: instanceImage
							});

							_.set(params, 'instanceImage', instanceImage);
						
							entityos._util.onComplete(params)		
						}
					);	
				}
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-instance-image-create',
			code: function ()
			{
				entityos.invoke('util-aws-ec2-instance-image-create',
				{
					onComplete: 'app-process-aws-ec2-instance-image-create-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-instance-image-create-process',
			code: function (params)
			{
				let responseData =
				{
					instanceImage: _.get(params, 'instanceImage')
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		//-- EC2 SNAPSHOTS DELETE ORPHANED

		entityos.add(
		{
			name: 'app-process-aws-ec2-instance-image-snapshots-orphaned-delete-oldest',
			code: function ()
			{
				entityos.invoke('util-aws-ec2-instance-images',
				{
					onComplete: 'app-process-aws-ec2-instance-image-snapshots-orphaned-delete-oldest-snapshots'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-instance-image-snapshots-orphaned-delete-oldest-snapshots',
			code: function ()
			{
				entityos.invoke('util-aws-ec2-snapshots',
				{
					onComplete: 'app-process-aws-ec2-instance-image-snapshots-orphaned-delete-oldest-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-instance-image-snapshots-orphaned-delete-oldest-process',
			code: function (params)
			{
				let instanceImages = entityos.get(
				{
					scope: 'ec2',
					context: 'instanceImages'
				});
				
				let	instanceImageSnapshots = entityos.get(
				{
					scope: 'ec2',
					context: 'snapshots'
				});

				console.table(instanceImages);
				console.table(instanceImageSnapshots);
				
				// Always leave one snapshot

				let instanceImageSnapshotsOrphaned = [];

				if (instanceImageSnapshots.length > 1)
				{
					_.each(instanceImageSnapshots, function (instanceImageSnapshot)
					{
						console.log(instanceImageSnapshot);

						if (_.includes(instanceImageSnapshot.description, 'Created by CreateImage'))
						{
							const _description = instanceImageSnapshot.description.match(/ami-\w+/);
							if (_description != undefined)
							{
								if (!_.find(instanceImages, function (instanceImage)
								{
									return (instanceImage.imageId == _.first(_description))
								}))
								{
									instanceImageSnapshotsOrphaned.push(instanceImageSnapshot)
								}
							}
						}
					});

					console.table(instanceImageSnapshotsOrphaned)

					const event = entityos.get({scope: '_event'});
					const instanceImageSnapshotOlderThanHours = parseInt(_.get(event, 'snapshot.olderThanHours', 48));

					const currentDate = moment();

					instanceImageSnapshotsOrphaned = instanceImageSnapshotsOrphaned.filter((image) => {
						const creationDate = moment(image.creationDate);
						return currentDate.diff(creationDate, 'hours') >= instanceImageSnapshotOlderThanHours;
					});

					instanceImageSnapshotsOrphaned = _.sortBy(instanceImageSnapshotsOrphaned, (image) => {
						return -moment(image.creationDate).valueOf();
					});

					const instanceImageSnapshotOrphanedToDelete = _.last(instanceImageSnapshotsOrphaned);

					if (instanceImageSnapshotOrphanedToDelete != undefined)
					{
						console.table(instanceImageSnapshotOrphanedToDelete);

						entityos.invoke('util-aws-ec2-snapshot-delete',
						{
							snapshotID: instanceImageSnapshotOrphanedToDelete.snapshotId
						});
					}
					else
					{
						entityos.invoke('util-end', 'No orphaned snapshots or snapshots older than ' + instanceImageSnapshotOlderThanHours + ' hours.', '200');
					}
				}
				else
				{
					entityos.invoke('util-end', 'No instance image snapshots', '200');
				}
			}
		});

		//-- EC2 SNAPSHOTS

		entityos.add(
		{
			name: 'util-aws-ec2-snapshots',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const snapshotID = _.get(event, 'snapshot.id');

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
		
				const { EC2Client, DescribeSnapshotsCommand } = require("@aws-sdk/client-ec2");

				const ec2 = new EC2Client(infrastructureConfig);

				let commandParams =
				{
					OwnerIds: ["self"]
				};

				if (snapshotID != undefined)
				{
					commandParams.Filters =
					[
						{
							Name: "name",
							Values: [snapshotID]
						}
					]	
				}

				const command = new DescribeSnapshotsCommand(commandParams);

				ec2.send(command).then(function(response)
					{
						let snapshots = response.Snapshots?.map((snapshot) => ({
							snapshotId: snapshot.SnapshotId,
							description: snapshot.Description,
							completionTime: snapshot.CompletionTime,
							creationDate: snapshot.StartTime,
							volumeId: snapshot.VolumeId,
							progress: snapshot.Progress,
							state: snapshot.State,
							volumeSize: snapshot.VolumeSize,
							encrypted: snapshot.Encrypted
						}));

						

						snapshots = _.sortBy(snapshots, (snapshot) => {
							return -moment(snapshot.creationDate).valueOf();
						});

						console.table(snapshots)

						entityos.set(
						{
							scope: 'ec2',
							context: 'snapshots',
							value: snapshots
						});

						params.snapshots = snapshots;
						entityos._util.onComplete(params)		
					}
				);
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-snapshots',
			code: function ()
			{
				entityos.invoke('util-aws-ec2-snapshots',
				{
					onComplete: 'app-process-aws-ec2-snapshots-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-snapshots-process',
			code: function (params)
			{
				let responseData =
				{
					snapshots: _.get(params, 'snapshots')
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-snapshot-export',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const snapshotID = _.get(event, 'snapshot.id');
				const bucketName = _.get(event, 'bucket.name');
				const bucketFolderName = _.get(event, 'bucket.folderName');

				if (snapshotID == undefined || bucketName == undefined)
				{
					entityos.invoke('util-end', 'No snapshot.id or bucket.name set', '200');
				}
				else
				{
					let commandParams =
					{
						Description: 'Exporting EBS snapshot [' + snapshotID + '] to S3',
						SnapshotId: snapshotID,
						S3Bucket: bucketName
					};

					if (bucketFolderName != undefined)
					{
						commandParams.S3Prefix = bucketFolderName;
					}
			
					const infrastructureConfig = entityos.invoke('util-aws-get-config');

					// TODO
				}
			}
		});

		entityos.add(
		{
			name: 'util-aws-ec2-snapshot-delete',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});
				const settings = entityos.get({scope: '_settings'});

				const settingsDeleteKey = _.get(settings, 'infrastructure.aws.keys.delete');
				const eventDeleteKey = _.get(event, 'deletekey');

				if (settingsDeleteKey != eventDeleteKey)
				{
					entityos.invoke('util-end', 'DeleteKey not valid.', '200');
				}
				else
				{
					let snapshotID = _.get(param, 'snapshotID');

					if (snapshotID == undefined)
					{
						snapshotID = _.get(event, 'snapshot.id');
					}

					if (snapshotID == undefined)
					{
						entityos.invoke('util-end', 'No snapshot.id set', '200');
					}
					else
					{
						let commandParams =
						{
							SnapshotId: snapshotID
						}

						const infrastructureConfig = entityos.invoke('util-aws-get-config');
					
						const { EC2Client, DeleteSnapshotCommand } = require("@aws-sdk/client-ec2");
						const ec2 = new EC2Client(infrastructureConfig);

						const command = new DeleteSnapshotCommand(commandParams);

						ec2.send(command).then(function(response)
							{
								console.table(response)
								let responseData = response;
								delete responseData['$metadata'];

								entityos.invoke('util-end', responseData, '200');
							}
						);
					}
				}
			}
		});

		//-- EC2 SECURITY-GROUPS

		entityos.add(
		{
			name: 'util-aws-ec2-security-groups',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const securityGroupID = _.get(event, 'securityGroup.id');

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
		
				const { EC2Client, DescribeSecurityGroupsCommand } = require("@aws-sdk/client-ec2");

				const ec2 = new EC2Client(infrastructureConfig);

				let commandParams = {};

				if (securityGroupID != undefined)
				{
					commandParams.GroupId = securityGroupID;
				}

				const command = new DescribeSecurityGroupsCommand(commandParams);

				ec2.send(command).then(function(response)
					{
						let securityGroups = response.SecurityGroups?.map((securitygroup) => ({
							groupID: securitygroup.GroupId,
							groupName: securitygroup.GroupName,
							description: securitygroup.Description,
							vpcID: securitygroup.VpcId,
							ipPermissions: securitygroup.IpPermissions,
							ipPermissionsEgress: securitygroup.IpPermissionsEgress,
							tags: securitygroup.Tags
						}));

						securityGroups = _.sortBy(securityGroups, 'groupName');

						console.table(securityGroups);

						entityos.set(
						{
							scope: 'ec2',
							context: 'securityGroups',
							value: securityGroups
						});

						let ipPermissions = [];

						_.each(securityGroups, function (securityGroup)
						{
							_.each(securityGroup.ipPermissions, function (ipPermission)
							{
								const _ipPermissions =
								{
									protocol: ipPermission.IpProtocol,
									fromPort: ipPermission.FromPort,
									toPort: ipPermission.ToPort,
									cidrRanges: ipPermission.IpRanges.map((range) => range.CidrIp).join(", "),
									ipv6Ranges: ipPermission.Ipv6Ranges.map((range) => range.CidrIpv6).join(", "),
									securityGroups: ipPermission.UserIdGroupPairs.map((pair) => pair.GroupId).join(", "),
									securityGroupName: securityGroup.groupName
								}

								_ipPermissions.public = (_ipPermissions.cidrRanges == '0.0.0.0/0');

								ipPermissions.push(_ipPermissions);
							});
						});

						ipPermissions = _.sortBy(ipPermissions, 'cidrRanges');

						const ipPermissionsPublic = _.filter(ipPermissions, function (ipPermission)
						{
							return ipPermission.public;
						});

						console.table(ipPermissions);

						_.set(params, 'securityGroups', securityGroups);
						_.set(params, 'ipPermissions', ipPermissions);
						_.set(params, 'ipPermissionsPublic', ipPermissionsPublic);

						entityos._util.onComplete(params)		
					}
				);
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-security-groups',
			code: function ()
			{
				entityos.invoke('util-aws-ec2-security-groups',
				{
					onComplete: 'app-process-aws-ec2-security-groups-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-security-groups-process',
			code: function (params)
			{
				let responseData =
				{
					securityGroups: _.get(params, 'securityGroups'),
					ipPermissions: _.get(params, 'ipPermissions'),
					ipPermissionsPublic: _.get(params, 'ipPermissionsPublic')
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		//-- EC2 SECURITY-GROUP-RULES

		entityos.add(
		{
			name: 'util-aws-ec2-security-group-rules',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const securityGroupID = _.get(event, 'securityGroup.id');

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
		
				const { EC2Client, DescribeSecurityGroupRulesCommand } = require("@aws-sdk/client-ec2");

				const ec2 = new EC2Client(infrastructureConfig);

				let commandParams = {};

				if (securityGroupID != undefined)
				{
					commandParams.Filters = [
					{
						Name: "group-id",
						Values: [securityGroupID],
					}]
				}

				const command = new DescribeSecurityGroupRulesCommand(commandParams);

				ec2.send(command).then(function(response)
					{
						let securityGroupRules = response.SecurityGroupRules?.map((securityGroupRule) => ({
							ruleID: securityGroupRule.SecurityGroupRuleId,
							groupID: securityGroupRule.GroupId,
							protocol: securityGroupRule.IpProtocol,
							fromPort: securityGroupRule.FromPort,
							toPort: securityGroupRule.ToPort,
							cidrIpv4: securityGroupRule.CidrIpv4,
							cidrIpv6: securityGroupRule.CidrIpv6,
							isEgress: securityGroupRule.IsEgress,
							inbound: !securityGroupRule.IsEgress,
							outbound: securityGroupRule.IsEgress,
							tags: securityGroupRule.Tags
						}));

						console.table(securityGroupRules);

						entityos.set(
						{
							scope: 'ec2',
							context: 'securityGroupRules',
							value: securityGroupRules
						});

						_.each(securityGroupRules, function (securityGroupRule)
						{
							securityGroupRule.public = (securityGroupRule.cidrIpv4 == '0.0.0.0/0');
						});

						securityGroupRules = _.sortBy(securityGroupRules, 'cidrIpv4');

						const securityGroupRulesPublic = _.filter(securityGroupRules, function (securityGroupRule)
						{
							return securityGroupRule.public;
						});

						_.set(params, 'securityGroupRules', securityGroupRules);
						_.set(params, 'securityGroupRulesPublic', securityGroupRulesPublic);

						_.set(params, 'securityGroupRulesInbound', _.filter(_.get(params, 'securityGroupRules'), function (rule) {return rule.inbound}));
						_.set(params, 'securityGroupRulesPublicInbound', _.filter(_.get(params, 'securityGroupRulesPublic'), function (rule) {return rule.inbound}));

						entityos._util.onComplete(params)		
					}
				);
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-security-group-rules',
			code: function ()
			{
				entityos.invoke('util-aws-ec2-security-group-rules',
				{
					onComplete: 'app-process-aws-ec2-security-group-rules-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-security-group-rules-process',
			code: function (params)
			{
				let responseData =
				{
					securityGroupRules: _.get(params, 'securityGroupRules'),
					securityGroupRulesPublic: _.get(params, 'securityGroupRulesPublic'),
					securityGroupRulesInbound: _.get(params, 'securityGroupRulesInbound'),
					securityGroupRulesPublicInbound: _.get(params, 'securityGroupRulesPublicInbound'),
				}

				console.log(responseData.securityGroupRulesPublicInbound)

				entityos.invoke('util-end', responseData, '200');
			}
		});

		//-- EC2 | SECURITY-GROUPS | CHANGE RULES

		entityos.add(
		{
			name: 'app-process-aws-ec2-security-group-rules-change',
			code: function ()
			{
				entityos.invoke('util-aws-ec2-security-groups',
				{
					onComplete: 'app-process-aws-ec2-security-group-rules-change-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-security-group-rules-change-process',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const securityGroupNames = _.get(event, 'securityGroup.names');

				const action = _.get(event, 'action');

				if (action == undefined || securityGroupNames == undefined)
				{
					entityos.invoke('util-end', 'No action or groupNames set', '200');
				}
				else
				{
					let securityGroupsAll = _.get(params, 'securityGroups');
					const securityGroupNames = _.get(event, 'securityGroup.names');
					let securityGroups = [];

					_.each(securityGroupNames, function (securityGroupName)
					{
						const securityGroup = _.find(securityGroupsAll, function(securityGroup)
						{
							return securityGroup.groupName == securityGroupName
						});

						if (securityGroup != undefined)
						{
							securityGroups.push(
							{
								name: securityGroup.groupName,
								id: securityGroup.groupID,
							});
						}
					});

					if (securityGroups.length == 0)
					{
						entityos.invoke('util-end', 'No security groups set', '200');
					}
					else
					{
						_.set(event, 'securityGroupsToProcessIndex', 0);
						_.set(event, 'securityGroupsToProcess', securityGroups);
						entityos.invoke('util-aws-ec2-security-group-rules-change-action-process', params);
					}
				}
			}
		});

		entityos.add(
		{
			name: 'util-aws-ec2-security-group-rules-change-get-permissions',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				let ipPermissions = _.get(event, 'ipPermissions');

				if (ipPermissions == 'public')
				{
					ipPermissions = 
					[
						{
							IpProtocol: "tcp",
							FromPort: 80,
							ToPort: 80,
							IpRanges: [
								{
									CidrIp: "0.0.0.0/0",
									Description: "Allow HTTP traffic"
								}
							]
						},
						{
							IpProtocol: "tcp",
							FromPort: 443,
							ToPort: 443,
							IpRanges: [
								{
									CidrIp: "0.0.0.0/0",
									Description: "Allow HTTPS traffic"
								}
							]
						}
					]
				}

				return ipPermissions;
			}
		});

		entityos.add(
		{
			name: 'util-aws-ec2-security-group-rules-change-action-process',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const action = _.get(event, 'action');
			
				const securityGroupsToProcess = _.get(event, 'securityGroupsToProcess');
				const securityGroupsToProcessIndex = _.get(event, 'securityGroupsToProcessIndex');
			
				if (securityGroupsToProcessIndex == securityGroupsToProcess.length)
				{
					let responseData = {message: 'Rule changes processed', rulesProcessed: securityGroupsToProcess};
					entityos.invoke('util-end', responseData, '200');
				}
				else
				{
					const securityGroup = securityGroupsToProcess[securityGroupsToProcessIndex];

					let commandParams =
					{
						GroupId: securityGroup.id
					};
	
					const infrastructureConfig = entityos.invoke('util-aws-get-config');
				
					const { EC2Client, AuthorizeSecurityGroupIngressCommand, RevokeSecurityGroupIngressCommand } = require("@aws-sdk/client-ec2");

					const ec2 = new EC2Client(infrastructureConfig);

					let command;
					
					if (action == 'add' || action == 'authorize')
					{
						commandParams.IpPermissions = entityos.invoke('util-aws-ec2-security-group-rules-change-get-permissions');
						command = new AuthorizeSecurityGroupIngressCommand(commandParams);
					}

					if (action == 'remove' || action == 'revoke')
					{
						const defaultSecurityGroupRuleIDs = _.get(event, 'securityGroupRules.ids');

						let securityGroupRuleIDs;
						if (securityGroup.ruleID != undefined)
						{
							securityGroupRuleIDs = [securityGroup.ruleID]
						}
						else
						{
							securityGroupRuleIDs = defaultSecurityGroupRuleIDs
						}

						if (securityGroupRuleIDs != undefined)
						{
							commandParams.SecurityGroupRuleIds = securityGroupRuleIDs;
						}
						else
						{
							commandParams.IpPermissions = entityos.invoke('util-aws-ec2-security-group-rules-change-get-permissions');
						}

						command = new RevokeSecurityGroupIngressCommand(commandParams);
					}

					ec2.send(command).then(function(response)
					{
						entityos.invoke('util-aws-ec2-security-group-rules-change-action-next', params);
					})
					.catch(function(response)
					{
						entityos.invoke('util-aws-ec2-security-group-rules-change-action-next', params);
					});	
				}
			}
		});

		entityos.add(
		{
			name: 'util-aws-ec2-security-group-rules-change-action-next',
			code: function (params)
			{
				let securityGroupsToProcessIndex = _.get(event, 'securityGroupsToProcessIndex');
				_.set(event, 'securityGroupsToProcessIndex', (securityGroupsToProcessIndex + 1));
				entityos.invoke('util-aws-ec2-security-group-rules-change-action-process', params);
			}
		});

		// EC2 | SECURITY-GROUPS | REVOKE PUBLIC

		entityos.add(
		{
			name: 'app-process-aws-ec2-security-group-rules-change-public',
			code: function ()
			{
				entityos.invoke('util-aws-ec2-security-group-rules',
				{
					onComplete: 'app-process-aws-ec2-security-group-rules-change-public-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-ec2-security-group-rules-change-public-process',
			code: function (params)
			{
				let securityGroupRulesPublicInbound = _.get(params, 'securityGroupRulesPublicInbound');

				if (securityGroupRulesPublicInbound.length == 0)
				{
					entityos.invoke('util-end', 'No public rules', '200');
				}
				else
				{
					const securityGroupsToProcess = _.map(securityGroupRulesPublicInbound, function (rule)
					{
						return {
							ruleID: rule.ruleID,
							id: rule.groupID
						}
					});

					console.table(securityGroupsToProcess);
				
					_.set(event, 'securityGroupsToProcessIndex', 0);
					_.set(event, 'securityGroupsToProcess', securityGroupsToProcess);
					entityos.invoke('util-aws-ec2-security-group-rules-change-action-process', params);
				}
			}
		});

		//-- S3 | STORAGE | BUCKETS

		entityos.add(
		{
			name: 'util-aws-s3-buckets',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const infrastructureConfig = entityos.invoke('util-aws-get-config');
		
				const { S3Client, ListBucketsCommand } = require("@aws-sdk/client-s3");

				const s3 = new S3Client(infrastructureConfig);

				let commandParams = {};
				const command = new ListBucketsCommand(commandParams);

				s3.send(command).then(function(response)
				{
					let buckets = response.Buckets?.map((bucket) => ({
						name: bucket.Name,
						creationDate: bucket.CreationDate
					}));

					console.table(buckets)

					entityos.set(
					{
						scope: 's3',
						context: 'buckets',
						value: buckets
					});

					params.buckets = buckets;
					entityos._util.onComplete(params)		
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-buckets',
			code: function ()
			{
				entityos.invoke('util-aws-s3-buckets',
				{
					onComplete: 'app-process-aws-s3-buckets-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-buckets-process',
			code: function (params)
			{
				let responseData =
				{
					buckets: _.get(params, 'buckets')
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		entityos.add(
		{
			name: 'util-aws-s3-bucket-create',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});

				const bucketName = _.get(event, 'bucket.name');
				const region = _.get(event, 'bucket.region'); // optional override
				const acl = _.get(event, 'bucket.acl'); // eg 'private' (optional)
				const bucketCreateConfiguration = _.get(event, 'bucket.createConfiguration'); // optional, advanced

				if (bucketName == undefined)
				{
					entityos.invoke('util-end', 'Missing bucket.name' + error.message, '401');
				}
				else
				{
					const infrastructureConfig = entityos.invoke('util-aws-get-config');

					if (region != undefined)
					{
						infrastructureConfig.region = region;
					}

					const { S3Client, CreateBucketCommand } = require("@aws-sdk/client-s3");

					const s3 = new S3Client(infrastructureConfig);

					let commandParams =
					{
						Bucket: bucketName
					};

					if (acl != undefined)
					{
						commandParams.ACL = acl;
					}

					// If user explicitly provided CreateBucketConfiguration, use it.
					// Otherwise, apply the standard AWS rule: omit it for us-east-1.
					if (bucketCreateConfiguration != undefined)
					{
						commandParams.CreateBucketConfiguration = bucketCreateConfiguration;
					}
					else
					{
						const _region = infrastructureConfig.region;

						if (_region != undefined && _region != 'us-east-1')
						{
							commandParams.CreateBucketConfiguration =
							{
								LocationConstraint: _region
							};
						}
					}

					console.table(commandParams);

					const command = new CreateBucketCommand(commandParams);

					s3.send(command).then(function(response)
					{
						console.table(response);

						entityos.set(
						{
							scope: 's3',
							context: 'bucket-create',
							value: response
						});

						param.bucketCreate = response;

						param.bucketName = bucketName;
						param.bucketLocation = response.Location;

						entityos._util.onComplete(param);
					})
					.catch(function(err)
					{
						entityos.set(
						{
							scope: 's3',
							context: 'bucket-create-error',
							value: err
						});

						param.error = err;
						entityos._util.onComplete(param);
					});
				}
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-create',
			code: function ()
			{
				entityos.invoke('util-aws-s3-bucket-create',
				{
					onComplete: 'app-process-aws-s3-bucket-create-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-create-process',
			code: function (param)
			{
				console.log(param);

				let responseData =
				{
					bucketLocation: _.get(param, 'bucketLocation'),
					bucketName: _.get(param, 'bucketName')
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		//-- S3 | STORAGE | BUCKET OBJECTS

		entityos.add(
		{
			name: 'util-aws-s3-bucket-objects',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});

				const bucketName = _.get(event, 'bucket.name');
				const folder = _.get(event, 'bucket.folder');

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
		
				const { S3Client, ListObjectsV2Command } = require("@aws-sdk/client-s3");

				const s3 = new S3Client(infrastructureConfig);

				let commandParams =
				{
					Bucket: bucketName
				};

				if (folder != undefined)
				{
					commandParams.Prefix = folder;
				}
					
				const command = new ListObjectsV2Command(commandParams);

				s3.send(command).then(function(response)
				{					
					const objects = response.Contents.sort((a, b) => 
						new Date(b.LastModified) - new Date(a.LastModified)
					);

					console.table(_.take(objects,2))
					
					entityos.set(
					{
						scope: 's3',
						context: 'objects',
						value: objects
					});

					params.objects = objects;
					entityos._util.onComplete(params)
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-objects',
			code: function ()
			{
				entityos.invoke('util-aws-s3-bucket-objects',
				{
					onComplete: 'app-process-aws-s3-bucket-objects-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-objects-process',
			code: function (params)
			{
				let responseData =
				{
					objects: _.get(params, 'objects')
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		//-- S3 | PUT AN OBJECT (FILE)

		entityos.add(
		{
			name: 'util-aws-s3-bucket-object-create',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});

				const bucketName = _.get(event, 'bucket.name');
				const folder = _.get(event, 'bucket.folder');
				const fileName = _.get(event, 'file.name');
				const fileContentType = _.get(event, 'file.contentType', 'application/octet-stream');
						//application/json
				let fileData = _.get(event, 'file.data');
				const fileDataIsBase64 = _.get(event, 'file.dataIsBase64');

				let s3Key = _.get(event, 'key');
				if (s3Key == undefined)
				{
					s3Key = folder + '/' + fileName;
				}

				if (bucketName == undefined)
				{}
				else
				{
					const infrastructureConfig = entityos.invoke('util-aws-get-config');
			
					const { S3Client, PutObjectCommand } = require("@aws-sdk/client-s3");

					const s3 = new S3Client(infrastructureConfig);

					if (fileContentType == 'application/octet-stream')
					{
						if (fileDataIsBase64)
						{
							fileData = Buffer.from(fileData, 'base64');
						}
						else
						{
							fileData = Buffer.from(fileData);
						}
					}

					if (fileContentType == 'application/json' && _.isPlainObject(fileData))
					{	
						fileData = JSON.stringify(fileData)
					}

					let commandParams =
					{
						Bucket: bucketName,
						Key: s3Key,
						ContentType: fileContentType,
						Body: fileData
					};

					console.table(commandParams);

					const command = new PutObjectCommand(commandParams);

					s3.send(command).then(function(response)
					{
						console.table(response)

						entityos.set(
						{
							scope: 's3',
							context: 'bucket-object-create',
							value: response
						});

						param.objectCreateETag = response.ETag;
						entityos._util.onComplete(param)		
					});
				}
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-object-create',
			code: function ()
			{
				entityos.invoke('util-aws-s3-bucket-object-create',
				{
					onComplete: 'app-process-aws-s3-bucket-object-create-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-object-create-process',
			code: function (param)
			{
				let responseData =
				{
					objectCreateETag: _.get(param, 'objectCreateETag')
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		//-- S3 | GET AN OBJECT (FILE)

		entityos.add(
		{
			name: 'util-aws-s3-bucket-object-get',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});

				const bucketName = _.get(event, 'bucket.name');
				const folder = _.get(event, 'bucket.folder');
				const fileName = _.get(event, 'file.name');
				const fileContentType = _.get(event, 'file.contentType', 'application/octet-stream');
						//application/json
				const fileDataIsBase64 = _.get(event, 'file.dataIsBase64');
				let fileDataIsJSON = _.get(event, 'file.dataIsJSON');

				if (fileDataIsJSON == undefined && _.includes(_.toLower(fileName), '.json'))
				{
					fileDataIsJSON = true;
				}

				let s3Key = _.get(event, 'key');
				if (s3Key == undefined)
				{
					s3Key = folder + '/' + fileName;
				}

				function streamToString(stream)
				{
					const chunks = [];
					return new Promise((resolve, reject) => {
					stream.on("data", chunk => chunks.push(chunk));
					stream.on("end", () => resolve(Buffer.concat(chunks).toString("utf-8")));
					stream.on("error", reject);
					});
				}

				if (bucketName == undefined)
				{}
				else
				{
					const infrastructureConfig = entityos.invoke('util-aws-get-config');
			
					const { S3Client, GetObjectCommand } = require("@aws-sdk/client-s3");

					const s3 = new S3Client(infrastructureConfig);

					let commandParams =
					{
						Bucket: bucketName,
						Key: s3Key
					};

					console.table(commandParams);

					const command = new GetObjectCommand(commandParams);

					s3.send(command).then(function(response)
					{
						streamToString(response.Body).then(function(data)
						{
							entityos.set(
							{
								scope: 's3',
								context: 'bucket-object-get',
								value: data
							});

							param.fileData = data;
							if (fileDataIsJSON)
							{
								param._fileData = JSON.parse(data);
							}
							entityos._util.onComplete(param)		
						});
					});
				}
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-object-get',
			code: function ()
			{
				entityos.invoke('util-aws-s3-bucket-object-get',
				{
					onComplete: 'app-process-aws-s3-bucket-object-get-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-object-get-process',
			code: function (param)
			{
				entityos.invoke('util-end', param, '200');
			}
		});

		//-- S3 | GET FILE FROM ENTITYOS & UPLOAD TO S3

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-object-create-from-entityos',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});
				
				const useSSM = _.get(event, 'data.settings.useSSM', false)

				if (useSSM)
				{
					const { SSMClient, GetParameterCommand} = require("@aws-sdk/client-ssm");
					const infrastructureConfig = entityos.invoke('util-aws-get-config');

					const ssm = new SSMClient(infrastructureConfig);

					let commandParams = {
						Name: "/entityos/create_from_entityos_attachment_id",
						WithDecryption: true,
					};

					const command = new GetParameterCommand(commandParams);

					ssm.send(command)
					.then(function(response)
					{
						console.log(response.Parameter.Value);

						entityos.set(
						{
							scope: 'aws-s3-bucket-object-create-from-entityos',
							context: 'attachmentID',
							value: response.Parameter.Value
						});

						entityos.invoke('app-process-aws-s3-bucket-object-create-from-entityos-process')
					})
					.catch(function(response)
					{
						entityos.set(
						{
							scope: 'aws-s3-bucket-object-create-from-entityos',
							context: 'attachmentID',
							value: -1
						});

						entityos.invoke('app-process-aws-s3-bucket-object-create-from-entityos-process');
					});
				}
				else
				{
					_.set(event, 'file.name', _.get(event, 'data.settings.object'));
					_.set(event, 'file.contentType', 'application/json');
					
					entityos.invoke('util-aws-s3-bucket-object-get',
					{
						onComplete: 'app-process-aws-s3-bucket-object-create-from-entityos-settings'
					});
				}
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-object-create-from-entityos-settings',
			code: function (param)
			{
				console.table(param);

				const attachmentLastID = _.get(param, '_fileData.attachments.lastid', -1);

				entityos.set(
				{
					scope: 'aws-s3-bucket-object-create-from-entityos',
					context: 'attachmentLastID',
					value: attachmentLastID
				});

				console.log(attachmentLastID)

				entityos.invoke('app-process-aws-s3-bucket-object-create-from-entityos-search');
			}
		})

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-object-create-from-entityos-search',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});
			
				const attachmentLastID = entityos.get(
				{
					scope: 'aws-s3-bucket-object-create-from-entityos',
					context: 'attachmentLastID'
				});

				const allspaces = _.get(event, 'allspaces', 'Y');
				const attachmentsToProcess = _.get(event, 'attachmentsToProcess', 20);

				entityos.cloud.search(
				{
					object: 'core_attachment',
					fields: [
						{name: 'attachment'},
						{name: 'filename'},
						{name: 'attachment.createduser.space'},
						{name: 'guid'},
						{name: 'object'},
						{name: 'objectcontext'},
						{name: 'publictype'}
					],
					filters:
					[
						{
							field: 'id',
							comparison: 'GREATER_THAN',
							value: attachmentLastID
						},
						{
							field: 'sourcetype',
							comparison: 'EQUAL_TO',
							value: 1
						}
					],
					sorts:
					[
						{
							field: 'id',
							direction: 'asc'
						}
					],
					customOptions:
					[
						{
							name: 'allspaces',
							value: allspaces
						}

					],
					rows: attachmentsToProcess,
					callback: 'app-process-aws-s3-bucket-object-create-from-entityos-response',
					callbackParam: param
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-object-create-from-entityos-response',
			code: function (param, response)
			{
				const event = entityos.get({scope: '_event'});
			
				if (_.get(response, 'status') != 'OK')
				{
					entityos.invoke('util-end', 'Error getting attachments.', '500');
				}
				else
				{
					if (response.data.rows.length == 0)
					{
						entityos.invoke('util-end', 'No attachments to process.', '404');
					}
					else
					{
						entityos.set(
						{
							scope: 'aws-s3-bucket-object-create-from-entityos',
							context: 'attachments',
							value: response.data.rows
						});

						const attachmentsSortedBySpace = _.sortBy(response.data.rows, 'attachment.createduser.space');

						entityos.set(
						{
							scope: 'aws-s3-bucket-object-create-from-entityos',
							context: 'attachments-sorted-by-space',
							value: attachmentsSortedBySpace
						});

						entityos.set(
						{
							scope: 'aws-s3-bucket-object-create-from-entityos',
							context: 'attachmentsIndex',
							value: 0
						});

						entityos.invoke('app-process-aws-s3-bucket-object-create-from-entityos-download');
					}
				}
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-object-create-from-entityos-download',
			code: function (param, response)
			{
				let createFromEntityOS = entityos.get(
				{
					scope: 'aws-s3-bucket-object-create-from-entityos'
				});

				if (createFromEntityOS.attachmentsIndex == createFromEntityOS.attachments.length)
				{
					entityos.invoke('app-process-aws-s3-bucket-object-create-from-entityos-finalise');
				}
				else
				{
					let attachment = createFromEntityOS.attachments[createFromEntityOS.attachmentsIndex];

					console.table(attachment);
				
					const currentSpace = entityos.get(
					{
						scope: 'util-entityos-space-switch',
						context: 'currentSpace'
					});

					console.log('Current Space: ' + currentSpace)

					if (attachment['attachment.createduser.space'] != currentSpace)
					{
						entityos.invoke('util-entityos-space-switch',
						{
							space: attachment['attachment.createduser.space'],
							onComplete: 'app-process-aws-s3-bucket-object-create-from-entityos-download'
						});
					}
					else
					{
						entityos.set(
						{
							scope: 'aws-s3-bucket-object-create-from-entityos',
							context: 'attachment',
							value: attachment
						});

						const data =
						{
							id: attachment.id
						}
						
						entityos.cloud.invoke(
						{
							method: 'core_attachment_download_as_base64',
							data: data,
							callback: 'app-process-aws-s3-bucket-object-create-from-entityos-download-process',
						});
					}
				}
			}	
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-object-create-from-entityos-download-process',
			code: function (param, response)
			{
				if (_.get(response, 'status') != 'OK')
				{
					entityos.invoke('app-process-aws-s3-bucket-object-create-from-entityos-next');
				}
				else
				{
					let createFromEntityOS = entityos.get(
					{
						scope: 'aws-s3-bucket-object-create-from-entityos'
					});

					let attachment = createFromEntityOS.attachments[createFromEntityOS.attachmentsIndex];

					_.set(attachment, 'base64', response.base64)

					/*entityos.set(
					{
						scope: 'aws-s3-bucket-object-create-from-entityos',
						context: 'attachment',
						value: attachment
					});*/

					entityos.invoke('app-process-aws-s3-bucket-object-create-from-entityos-upload', param);
				}
			}	
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-object-create-from-entityos-upload',
			code: function (param)
			{
				let createFromEntityOS = entityos.get(
				{
					scope: 'aws-s3-bucket-object-create-from-entityos'
				});

				let attachment = createFromEntityOS.attachments[createFromEntityOS.attachmentsIndex];

				//publictype: 1=As Per Normal Object Rules [default],2=Public,3=Not Public

				let s3KeyPrefix = 'secure';
				if (attachment.publictype == '2')
				{
					s3KeyPrefix = 'public';
				}
				
				const s3Key = s3KeyPrefix + '/' +
								attachment['attachment.createduser.space'] + '/' +
								attachment['id'] + '-' +
								attachment['object'] + '-' +
								attachment['objectcontext'] + '--' +
								attachment.filename;

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
		
				const { S3Client, PutObjectCommand } = require("@aws-sdk/client-s3");

				const s3 = new S3Client(infrastructureConfig);

				const buffer = Buffer.from(attachment.base64, "base64");

				const event = entityos.get({scope: '_event'});
				const bucketName = _.get(event, 'bucket.name');

				console.log(s3Key)

				let commandParams =
				{
					Bucket: bucketName,
					Key: s3Key,
					Body: buffer,
					ContentType: 'application/octet-stream'
				};

				const command = new PutObjectCommand(commandParams);

				s3.send(command)
				.then(function(response)
				{
					console.table(response)
					entityos.invoke('app-process-aws-s3-bucket-object-create-from-entityos-settings-update', param, response)
					
				})
				.catch(function (response)
				{
					entityos.invoke('app-process-aws-s3-bucket-object-create-from-entityos-settings-update', param, response)
				});
			}	
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-object-create-from-entityos-settings-update',
			code: function (param, response)
			{
				const event = entityos.get({scope: '_event'});

				console.log(response);

				const useSSM = _.get(event, 'data.settings.useSSM', false)

				let attachment = entityos.get(
				{
					scope: 'aws-s3-bucket-object-create-from-entityos',
					context: 'attachment'
				});

				_.set(attachment.awsETag = response.ETag)

				if (useSSM)
				{

					const { SSMClient, PutParameterCommand} = require("@aws-sdk/client-ssm");
					const infrastructureConfig = entityos.invoke('util-aws-get-config');

					const ssm = new SSMClient(infrastructureConfig);

					//TODO; Get and set search is greater than so moves to next one.

					let commandParams = {
						Name: "/entityos/create_from_entityos_attachment_id",
						Value: attachment.id,
						Type: 'SecureString',
						Overwrite: true,
					};

					const command = new PutParameterCommand(commandParams);

					ssm.send(command)
					.then(function(response)
					{
					
						entityos.invoke('app-process-aws-s3-bucket-object-create-from-entityos-finalise')
					})
					.catch(function(response)
					{
						entityos.invoke('app-process-aws-s3-bucket-object-create-from-entityos-finalise');
					});
				}
				else
				{
					_.set(event, 'file.name', _.get(event, 'data.settings.object'));
					_.set(event, 'file.contentType', 'application/json');
				
					const fileData = {
						"attachments": {
							"lastid": attachment.id
						}
					}
					_.set(event, 'file.data', fileData);

					entityos.set({scope: '_event', value: event});

					console.table(event)
					
					entityos.invoke('util-aws-s3-bucket-object-create',
					{
						onComplete: 'app-process-aws-s3-bucket-object-create-from-entityos-next'
					});
				}	
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-object-create-from-entityos-next',
			code: function (param, response)
			{
				const createFromEntityOS = entityos.get(
				{
					scope: 'aws-s3-bucket-object-create-from-entityos'
				});

				entityos.set(
				{
					scope: 'aws-s3-bucket-object-create-from-entityos',
					context: 'attachmentsIndex',
					value: (createFromEntityOS.attachmentsIndex + 1)
				});

				entityos.invoke('app-process-aws-s3-bucket-object-create-from-entityos-download');
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-s3-bucket-object-create-from-entityos-finalise',
			code: function (param, response)
			{
				const createFromEntityOS = entityos.get(
				{
					scope: 'aws-s3-bucket-object-create-from-entityos'
				});

				if (createFromEntityOS.attachments.length == 0)
				{
					entityos.invoke('util-end', 'Nothing to process.', '200');
				}
				else
				{
					const attachments = _.map(createFromEntityOS.attachments, function (attachment)
					{
						return {
							id: attachment.id,
							awsETag: attachment.awsETag
						}

					});

					entityos.invoke('util-end', {attachments: attachments}, '200');
				}
			}
		});

		//-- RDS Instances ---

		entityos.add(
		{
			name: 'util-aws-rds-instances',
			code: function (params)
			{			
				const infrastructureConfig = entityos.invoke('util-aws-get-config');
		
				const { RDSClient, DescribeDBInstancesCommand } = require("@aws-sdk/client-rds");

				const rds = new RDSClient(infrastructureConfig);

				let commandParams = {};

				const command = new DescribeDBInstancesCommand(commandParams);

				rds.send(command).then(function(response)
					{
						console.log(response.DBInstances)
						const instances = response.DBInstances?.map((db) => ({
							DBInstanceIdentifier: db.DBInstanceIdentifier,
							Engine: db.Engine,
							DBInstanceStatus: db.DBInstanceStatus,
							Endpoint: db.Endpoint?.Address,
							InstanceCreateTime: db.InstanceCreateTime,
						}));

						console.table(instances)

						_.each(response.Reservations, function (reservation)
						{
							console.log(reservation.Instances);
						});

						entityos.set(
						{
							scope: 'rds',
							context: 'instances',
							value: instances
						});

						params.instances = instances;
						entityos._util.onComplete(params)		
					}
				);	
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-instances',
			code: function ()
			{
				entityos.invoke('util-aws-rds-instances',
				{
					onComplete: 'app-process-aws-rds-instances-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-instances-process',
			code: function (params)
			{
				let responseData =
				{
					instances: _.get(params, 'instances', {})
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-instance-change-state',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const instanceID = _.get(event, 'instance.id');

				const status = _.get(event, 'status');

				if (status == undefined || instanceID == undefined)
				{
					entityos.invoke('util-end', 'No status or instanceID set', '200');
				}
				else
				{
					let commandParams = {};

					if (instanceID != undefined)
					{
						commandParams.DBInstanceIdentifier = instanceID;
					}

					const infrastructureConfig = entityos.invoke('util-aws-get-config');
				
					const { RDSClient, StartDBInstanceCommand, StopDBInstanceCommand } = require("@aws-sdk/client-rds");

					const rds = new RDSClient(infrastructureConfig);

					let command;
					
					if (status == 'start')
					{
						command = new StartDBInstanceCommand(commandParams);
					}

					if (status == 'stop')
					{
						command = new StopDBInstanceCommand(commandParams);
					}

					rds.send(command).then(function(response)
						{
							let responseData = response;
							delete responseData['$metadata'];

							entityos.invoke('util-end', responseData, '200');
						}
					);	
				}
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-instance-delete',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const settings = entityos.get({scope: '_settings'});

				const settingsDeleteKey = _.get(settings, 'infrastructure.aws.keys.delete');
				const eventDeleteKey = _.get(event, 'deletekey');

				if (settingsDeleteKey != eventDeleteKey)
				{
					entityos.invoke('util-end', 'DeleteKey not valid.', '200');
				}
				else
				{
					const instanceID = _.get(event, 'instance.id');

					if (instanceID == undefined)
					{
						entityos.invoke('util-end', 'No instanceID set', '200');
					}
					else
					{
						let snapshotID = _.get(event, 'snapshot.id');

						if (snapshotID == undefined)
						{
							snapshotPrefix = _.get(event, 'snapshot.prefix', '');
							if (snapshotPrefix != '') {snapshotPrefix = snapshotPrefix + '-'}
							snapshotID = snapshotPrefix + instanceID + '-' + moment().format('YYYY-MM-DD-HH-mm').toUpperCase();
						}

						let commandParams =
						{
							DBInstanceIdentifier: instanceID,
							SkipFinalSnapshot: false,
							FinalDBSnapshotIdentifier: snapshotID
						}

						const infrastructureConfig = entityos.invoke('util-aws-get-config');
					
						const { RDSClient, DeleteDBInstanceCommand, } = require("@aws-sdk/client-rds");

						const rds = new RDSClient(infrastructureConfig);

						const command = new DeleteDBInstanceCommand(commandParams);

						rds.send(command).then(function(response)
							{
								let responseData = response;
								delete responseData['$metadata'];

								entityos.invoke('util-end', responseData, '200');
							}
						);
					}
				}
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-instance-restore',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});

				const instanceID = _.get(event, 'instance.id');

				// Use "aws-rds-instance-snapshots" to get the snapshotID
				const snapshotID = _.get(event, 'snapshot.id');
				const restoreParams = _.get(event, 'restore');
				
				if (instanceID == undefined || snapshotID == undefined)
				{
					entityos.invoke('util-end', 'No instance.id or snapshot.id set', '200');
				}
				else
				{
					let commandParams = _.assign(
					{
						DBSnapshotIdentifier: snapshotID,
						DBInstanceIdentifier: instanceID
					},
					restoreParams);

					const infrastructureConfig = entityos.invoke('util-aws-get-config');
				
					const { RDSClient, RestoreDBInstanceFromDBSnapshotCommand } = require("@aws-sdk/client-rds");

					const rds = new RDSClient(infrastructureConfig);

					const command = new RestoreDBInstanceFromDBSnapshotCommand(commandParams);

					rds.send(command).then(function(response)
						{
							let responseData = response;
							delete responseData['$metadata'];

							entityos.invoke('util-end', responseData, '200');
						}
					);
				}
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-instance-restore-last-snapshot',
			code: function ()
			{
				// Get snapshots 
				entityos.invoke('util-aws-rds-instance-snapshots',
				{
					onComplete: 'app-process-aws-rds-instance-restore-last-snapshot-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-instance-restore-last-snapshot-process',
			code: function (param)
			{
				//Sort to get the most recend for the instance
				let snapshots = _.get(param, 'snapshots');

					const mostRecentSnapshot = snapshots?.sort((a, b) => {
					return new Date(b.snapshotCreateTime) - new Date(a.snapshotCreateTime);
					})[0];

				if (mostRecentSnapshot == undefined)
				{
					entityos.invoke('util-end', {error: 'Can not find a snapshot to restore.'}, '401');
				}
				else
				{
					const event = entityos.get({scope: '_event'});
					_.set(event, 'snapshot.id', mostRecentSnapshot.dbSnapshotIdentifier);
					entityos.set({scope: '_event', value: event});

					entityos.invoke('app-process-aws-rds-instance-restore')
				}
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-instance-modify',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const instanceID = _.get(event, 'instance.id');

				const modify = _.get(event, 'modify');
				
				if (instanceID == undefined || modify == undefined)
				{
					entityos.invoke('util-end', 'No instance.id or modify set', '200');
				}
				else
				{
					let commandParams = _.assign(
					{
						DBInstanceIdentifier: instanceID
					},
					modify);

					const infrastructureConfig = entityos.invoke('util-aws-get-config');
				
					const { RDSClient, ModifyDBInstanceCommand } = require("@aws-sdk/client-rds");

					const rds = new RDSClient(infrastructureConfig);

					const command = new ModifyDBInstanceCommand(commandParams);

					rds.send(command).then(function(response)
						{
							let responseData = response;
							delete responseData['$metadata'];

							entityos.invoke('util-end', responseData, '200');
						}
					);
				}
			}
		});


		entityos.add(
		{
			name: 'app-process-aws-rds-instance-create',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const create = _.get(event, 'create');
				
				if (create == undefined)
				{
					entityos.invoke('util-end', 'No create options set', '200');
				}
				else
				{
					let commandParams = _.assign({}, _.get(create, 'options'));

					const infrastructureConfig = entityos.invoke('util-aws-get-config');
				
					const { RDSClient, CreateDBInstanceCommand } = require("@aws-sdk/client-rds");
					const rds = new RDSClient(infrastructureConfig);

					const command = new CreateDBInstanceCommand(commandParams);

					rds.send(command).then(function(response)
						{
							let responseData = response;
							delete responseData['$metadata'];

							entityos.invoke('util-end', responseData, '200');
						}
					);
				}
			}
		});

		//-- RDS CLUSTERS

		entityos.add(
		{
			name: 'app-process-aws-rds-cluster-create',
			notes: 'Create cluster for Aurora',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const create = _.get(event, 'create');
				
				let commandParams = _.assign({}, _.get(create, 'options'));

				const infrastructureConfig = entityos.invoke('util-aws-get-config');			
				const { RDSClient, CreateDBClusterCommand } = require("@aws-sdk/client-rds");
				const rds = new RDSClient(infrastructureConfig);

				const command = new CreateDBClusterCommand(commandParams);

				rds.send(command).then(function(response)
					{
						let responseData = response;
						delete responseData['$metadata'];

						entityos.invoke('util-end', responseData, '200');
					}
				);
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-clusters',
			notes: '',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				
				let commandParams = {};

				const infrastructureConfig = entityos.invoke('util-aws-get-config');			
				const { RDSClient, DescribeDBClustersCommand } = require("@aws-sdk/client-rds");
				const rds = new RDSClient(infrastructureConfig);

				const command = new DescribeDBClustersCommand(commandParams);

				rds.send(command).then(function(response)
					{
						console.log(response.DBClusters)

						entityos.invoke('util-end', {clusters: response.DBClusters}, '200');
					}
				);
			}
		});


		//-- RDS Snapshots

		entityos.add(
		{
			name: 'util-aws-rds-instance-snapshots',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const instanceID = _.get(event, 'instance.id');

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
		
				const { RDSClient, DescribeDBSnapshotsCommand } = require("@aws-sdk/client-rds");

				const rds = new RDSClient(infrastructureConfig);

				let commandParams = {};

				if (instanceID != undefined)
				{
					commandParams.DBInstanceIdentifier = instanceID;
				}

				const command = new DescribeDBSnapshotsCommand(commandParams);

				rds.send(command).then(function(response)
					{
						const snapshots = response.DBSnapshots?.map((snapshot) => ({
							dbSnapshotIdentifier: snapshot.DBSnapshotIdentifier,
							dbInstanceIdentifier: snapshot.DBInstanceIdentifier,
							snapshotType: snapshot.SnapshotType,
							status: snapshot.Status,
							snapshotCreateTime: snapshot.SnapshotCreateTime,
							percentProgress: snapshot.PercentProgress
						}));

						console.table(snapshots)

						entityos.set(
						{
							scope: 'rds',
							context: 'snapshots',
							value: snapshots
						});

						params.snapshots = snapshots;
						entityos._util.onComplete(params)		
					}
				);	
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-instance-snapshots',
			code: function ()
			{
				entityos.invoke('util-aws-rds-instance-snapshots',
				{
					onComplete: 'app-process-aws-rds-instance-snapshots-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-instance-snapshots-process',
			code: function (params)
			{
				let responseData =
				{
					snapshots: _.get(params, 'snapshots', {})
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-instance-snapshot-create',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const instanceID = _.get(event, 'instance.id');
				let snapshotID = _.get(event, 'snapshot.id');

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
		
				const { RDSClient, CreateDBSnapshotCommand } = require("@aws-sdk/client-rds");

				const rds = new RDSClient(infrastructureConfig);

				let commandParams = {};

				if (instanceID != undefined)
				{
					commandParams.DBInstanceIdentifier = instanceID;
				}

				if (snapshotID == undefined)
				{
					snapshotPrefix = _.get(event, 'snapshot.prefix', '');
					if (snapshotPrefix != '') {snapshotPrefix = snapshotPrefix + '-'}
					snapshotID = snapshotPrefix + instanceID + '-' + moment().format('YYYY-MM-DD-HH-mm').toUpperCase();
				}

				commandParams.DBSnapshotIdentifier = snapshotID;
				
				const command = new CreateDBSnapshotCommand(commandParams);

				rds.send(command).then(function(response)
					{
						console.log(response)
					}
				);
			}
		});

		//-- RDS | SNAPSHOT DELETE OLDEST

		entityos.add(
		{
			name: 'app-process-aws-rds-instance-snapshot-delete-oldest',
			code: function ()
			{
				entityos.invoke('util-aws-rds-instance-snapshots',
				{
					onComplete: 'app-process-aws-rds-instance-snapshot-delete-oldest-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-instance-snapshot-delete-oldest-process',
			code: function (params)
			{
				let instanceSnapshots = _.get(params, 'snapshots', []);

				if (instanceSnapshots.length > 1) // Don't delete the last one
				{
					const event = entityos.get({scope: '_event'});
					const instanceSnapshotOlderThanHours = parseInt(_.get(event, 'snapshot.olderThanHours', 48));

					const currentDate = moment();

					instanceSnapshots = instanceSnapshots.filter((snapshot) => {
						const creationDate = moment(snapshot.snapshotCreateTime);
						return currentDate.diff(creationDate, 'hours') >= instanceSnapshotOlderThanHours;
					});

					instanceSnapshots = _.sortBy(instanceSnapshots, (snapshot) => {
						return -moment(snapshot.snapshotCreateTime).valueOf();
					});

					console.table(instanceSnapshots);

					const instanceSnapshotToDelete = _.last(instanceSnapshots);

					if (instanceSnapshotToDelete != undefined)
					{
						console.table(instanceSnapshotToDelete);

						entityos.invoke('util-aws-rds-instance-snapshot-delete',
						{
							snapshotID: instanceSnapshotToDelete.dbSnapshotIdentifier
						});
					}
					else
					{
						entityos.invoke('util-end', 'No instance snapshots older than ' + instanceSnapshotOlderThanHours + ' hours.', '200');
					}
				}
				else
				{
					entityos.invoke('util-end', 'No instance snapshots', '200');
				}
			}
		});

		entityos.add(
		{
			name: 'util-aws-rds-instance-snapshot-delete',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});
				const settings = entityos.get({scope: '_settings'});

				const settingsDeleteKey = _.get(settings, 'infrastructure.aws.keys.delete');
				const eventDeleteKey = _.get(event, 'deletekey');

				if (settingsDeleteKey != eventDeleteKey)
				{
					entityos.invoke('util-end', 'DeleteKey not valid.', '200');
				}
				else
				{
					let snapshotID = _.get(param, 'snapshotID');

					if (snapshotID == undefined)
					{
						snapshotID = _.get(event, 'snapshot.id');
					}

					if (snapshotID == undefined)
					{
						entityos.invoke('util-end', 'No snapshot.id set', '200');
					}
					else
					{
						let commandParams =
						{
							DBSnapshotIdentifier: snapshotID
						}

						const infrastructureConfig = entityos.invoke('util-aws-get-config');
					
						const { RDSClient, DeleteDBSnapshotCommand } = require("@aws-sdk/client-rds");
						const rds = new RDSClient(infrastructureConfig);

						const command = new DeleteDBSnapshotCommand(commandParams);

						rds.send(command).then(function(response)
							{
								let responseData = response;
								delete responseData['$metadata'];

								entityos.invoke('util-end', responseData, '200');
							}
						);
					}
				}
			}
		});

		// RDS - SUBNET GROUPS

		entityos.add(
		{
			name: 'util-aws-rds-subnet-groups',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const subnetIDs = _.get(event, 'subnet.ids');

				const infrastructureConfig = entityos.invoke('util-aws-get-config');

				const { RDSClient, DescribeDBSubnetGroupsCommand } = require("@aws-sdk/client-rds");
				const rds = new RDSClient(infrastructureConfig);
				
				let commandParams = {};

				if (subnetIDs != undefined)
				{
					commandParams.SubnetIDs = subnetIDs
				}

				const command = new DescribeDBSubnetGroupsCommand(commandParams);

				rds.send(command).then(function(response)
					{
						console.log(response.DBSubnetGroups)

						const subnetGroups = response.DBSubnetGroups?.map((subnet) => ({
								name: subnet.DBSubnetGroupName,
								description: subnet.DBSubnetGroupDescription,
								status: subnet.SubnetGroupStatus,
								subnets: subnet.Subnets,
								arn: subnet.DBSubnetGroupArn,
								networkTypes: subnet.SupportedNetworkTypes,
								vpcID: subnet.VpcId
							}));
					
						console.table(subnetGroups)

						entityos.set(
						{
							scope: 'rds',
							context: 'subnetgroups',
							value: subnetGroups
						});

						params.subnetGroups = subnetGroups;
						entityos._util.onComplete(params)		
					}
				);	
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-subnet-groups',
			code: function ()
			{
				entityos.invoke('util-aws-rds-subnet-groups',
				{
					onComplete: 'app-process-aws-rds-subnet-groups-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-subnet-groups-process',
			code: function (params)
			{
				let responseData =
				{
					subnetGroups: _.get(params, 'subnetGroups', {})
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-rds-subnet-group-create',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
		
				let commandParams =
				{
					DBSubnetGroupName: _.get(event, 'group.name'),
      				DBSubnetGroupDescription:  _.get(event, 'group.description', 'Created by entityos-aws.'),
      				SubnetIds: _.get(event, 'group.subnets')
				}

				if (_.get(event, 'key.tags') != undefined)
				{
					commandParams.Tags = _.get(event, 'key.tags')
				}

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
			
				const { RDSClient, CreateDBSubnetGroupCommand } = require("@aws-sdk/client-rds");

				const rds = new RDSClient(infrastructureConfig);

				const command = new CreateDBSubnetGroupCommand(commandParams);

				rds.send(command).then(function(response)
					{
						console.log(response)

						const subnetGroup = response.DBSubnetGroup;
						
						let responseData =
						{
							subnetGroup: subnetGroup
						}

						entityos.invoke('util-end', responseData, '200');
					}
				);
			}
		});

		// ELBs

		entityos.add(
		{
			name: 'util-aws-elb-load-balancers',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const loadBalancerNames = _.get(event, 'loadbalancer.names');

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
		
				const { ElasticLoadBalancingV2Client, DescribeLoadBalancersCommand } = require("@aws-sdk/client-elastic-load-balancing-v2");

				const elb = new ElasticLoadBalancingV2Client(infrastructureConfig);

				let commandParams = {};

				if (loadBalancerNames != undefined)
				{
					commandParams.Names = loadBalancerNames;
				}

				const command = new DescribeLoadBalancersCommand(commandParams);

				elb.send(command).then(function(response)
					{
						console.log(response.LoadBalancers)
						const loadBalancers = response.LoadBalancers?.map((lb) => ({
							name: lb.LoadBalancerName,
							arn: lb.LoadBalancerArn,
							type: lb.Type,
							state: lb.State.Code,
							dnsName: lb.DNSName,
							vpcid: lb.VpcId,
							state: lb.State.Code,
							type: lb.Type,
							availabilityZones: lb.AvailabilityZones,
							securityGroups:lb.SecurityGroups,
						}));

						console.table(loadBalancers)

						entityos.set(
						{
							scope: 'elb',
							context: 'loadbalancers',
							value: loadBalancers
						});

						params.loadbalancers = loadBalancers;
						entityos._util.onComplete(params)		
					}
				);	
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-elb-load-balancers',
			code: function ()
			{
				entityos.invoke('util-aws-elb-load-balancers',
				{
					onComplete: 'app-process-aws-elb-load-balancers-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-elb-load-balancers-process',
			code: function (params)
			{
				let responseData =
				{
					loadbalancers: _.get(params, 'loadbalancers', {})
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-elb-load-balancer-listeners',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const settings = entityos.get({scope: '_settings'});

				const loadbalancerARN = _.get(event, 'loadbalancer.arn');

				if (loadbalancerARN == undefined)
				{
					entityos.invoke('util-end', 'No loadbalancer.arn set', '200');
				}
				else
				{
					let commandParams =
					{
						LoadBalancerArn: loadbalancerARN
					}

					const infrastructureConfig = entityos.invoke('util-aws-get-config');
				
					const { ElasticLoadBalancingV2Client, DescribeListenersCommand } = require("@aws-sdk/client-elastic-load-balancing-v2");

					const elb = new ElasticLoadBalancingV2Client(infrastructureConfig);

					const command = new DescribeListenersCommand(commandParams);

					elb.send(command).then(function(response)
						{
							console.log(response.Listeners)

							const listeners = response.Listeners;
							const httpsListener = _.find(listeners, function (listener)
							{
								return listener.Protocol == 'HTTPS';
							});

							let responseData =
							{
								listeners: listeners
							}

							if (httpsListener != undefined)
							{
								console.log(httpsListener.Certificates);
								responseData.httpsListenerPrimaryCertificate = httpsListener.Certificates;
							}

							entityos.invoke('util-end', responseData, '200');
						}
					);
				}
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-elb-load-balancer-listener-certificates',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});

				const listenerARN = _.get(event, 'loadbalancer.listener.arn');

				if (listenerARN == undefined)
				{
					entityos.invoke('util-end', 'No loadbalancer.listener.arn set', '200');
				}
				else
				{
					let commandParams =
					{
						ListenerArn: listenerARN
					}

					const infrastructureConfig = entityos.invoke('util-aws-get-config');
				
					const { ElasticLoadBalancingV2Client, DescribeListenerCertificatesCommand } = require("@aws-sdk/client-elastic-load-balancing-v2");

					const elb = new ElasticLoadBalancingV2Client(infrastructureConfig);

					const command = new DescribeListenerCertificatesCommand(commandParams);

					elb.send(command).then(function(response)
						{
							console.log(response.Certificates)

							const certificates = response.Certificates;
							
							let responseData =
							{
								certificates: certificates
							}

							entityos.invoke('util-end', responseData, '200');
						}
					);
				}
			}
		});

		//-- WAF | FIREWALLS

		entityos.add(
		{
			name: 'util-aws-waf-firewalls',
			code: function (params)
			{
				const event = entityos.get({scope: '_event'});
				const infrastructureConfig = entityos.invoke('util-aws-get-config');
		
				const { WAFV2Client, ListWebACLsCommand, GetWebACLCommand } = require("@aws-sdk/client-wafv2");

				const waf = new WAFV2Client(infrastructureConfig);

				let commandParams =
				{
					Scope: "REGIONAL"
				};
				const command = new ListWebACLsCommand(commandParams);

				waf.send(command).then(function(response)
					{
						console.log(response.Buckets)
						let firewalls = response.WebACLs?.map((webAcl) => ({
							name: webAcl.Name,
							id: webAcl.Id,
							arn: webAcl.ARN
						}));

						console.table(firewalls)

						entityos.set(
						{
							scope: 'waf',
							context: 'firewalls',
							value: firewalls
						});

						params.firewalls = firewalls;
						entityos._util.onComplete(params)		
					}
				);
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-waf-firewalls',
			code: function ()
			{
				entityos.invoke('util-aws-waf-firewalls',
				{
					onComplete: 'app-process-aws-waf-firewalls-process'
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-waf-firewalls-process',
			code: function (params)
			{
				let responseData =
				{
					firewalls: _.get(params, 'firewalls')
				}

				entityos.invoke('util-end', responseData, '200');
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-waf-firewall-rule-update-based-on-entityos-urls',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});
			
				const allspaces = _.get(event, 'allspaces', 'Y');
				const url = _.get(event, 'url');

				let filters = [];

				if (url != undefined)
				{
					filters.push(
					{
						field: 'url',
						comparison: 'TEXT_IS_LIKE',
						value: url
					});
				}

				entityos.cloud.search(
				{
					object: 'setup_site_url',
					fields: [
						{name: 'Site'},
						{name: 'Sitetext'},
						{name: 'URL'},
						{name: 'guid'},
						{name: 'primary'},
						{name: 'notes'}
					],
					filters: filters,
					sorts:
					[
						{
							field: 'site',
							direction: 'asc'
						}
					],
					customOptions:
					[
						{
							name: 'allspaces',
							value: allspaces
						}

					],
					rows: 99999,
					callback: 'app-process-aws-waf-firewall-rule-update-based-on-entityos-urls-response',
					callbackParam: param
				});
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-waf-firewall-rule-update-based-on-entityos-urls-response',
			code: function (param, response)
			{
				const event = entityos.get({scope: '_event'});
			
				if (_.get(response, 'status') != 'OK')
				{
					entityos.invoke('util-end', 'Error.', '500');
				}
				else
				{
					if (response.data.rows.length == 0)
					{
						entityos.invoke('util-end', 'No urls.', '404');
					}
					else
					{
						const urls = entityos.set(
						{
							scope: 'app-process-aws-waf-firewall-rule-update-based-on-entityos-urls',
							context: 'all',
							value: response.data.rows
						});

						console.table(urls);
					}
				}
			}
		});

		//-- ACM | CERTIFICATES

		entityos.add(
		{
			name: 'app-process-aws-acm-certificate',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const certificateARN = _.get(event, 'certificate.arn');

				if (certificateARN == undefined)
				{
					entityos.invoke('util-end', 'No certificate.arn set', '200');
				}
				else
				{
					const infrastructureConfig = entityos.invoke('util-aws-get-config');

					const { ACMClient, DescribeCertificateCommand } = require("@aws-sdk/client-acm");

					const acm = new ACMClient(infrastructureConfig);

					let commandParams =
					{
						CertificateArn: certificateARN
					};

					const command = new DescribeCertificateCommand(commandParams);

					acm.send(command).then(function(response)
						{
							console.log(response.Certificate)

							const certificate = response.Certificate;
							
							let responseData =
							{
								certificate: certificate
							}

							entityos.invoke('util-end', responseData, '200');
						}
					);
				}
			}
		});

		//-- ROUTE53 | DNS

		entityos.add(
		{
			name: 'app-process-aws-route53-zones',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});

				let commandParams = {}

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
			
				const { Route53Client, ListHostedZonesCommand } = require("@aws-sdk/client-route-53");

				const route53 = new Route53Client(infrastructureConfig);

				const command = new ListHostedZonesCommand(commandParams);

				route53.send(command).then(function(response)
					{
						console.log(response.HostedZones)

						const hostedZones = response.HostedZones;
						
						let responseData =
						{
							hostedZones: hostedZones
						}

						entityos.invoke('util-end', responseData, '200');
					}
				);
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-route53-zone-records',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const zoneID = _.get(event, 'zone.id');

				if (zoneID == undefined)
				{
					entityos.invoke('util-end', 'No zone.id set', '200');
				}
				else
				{
					let commandParams =
					{
							HostedZoneId: zoneID
					}

					const infrastructureConfig = entityos.invoke('util-aws-get-config');
				
					const { Route53Client, ListResourceRecordSetsCommand } = require("@aws-sdk/client-route-53");

					const route53 = new Route53Client(infrastructureConfig);

					const command = new ListResourceRecordSetsCommand(commandParams);

					function decodeOctal(input) {
						return input.replace(/\\([0-7]{3})/g, (match, octal) => {
						const asciiValue = parseInt(octal, 8); // Convert octal to decimal
						return String.fromCharCode(asciiValue); // Convert decimal to ASCII
						});
					}

					route53.send(command).then(function(response)
						{
							_.each(response.ResourceRecordSets, function (record)
							{
								record._name = decodeOctal(record.Name)
							})
							
							console.log(response.ResourceRecordSets)

							const zoneRecords = response.ResourceRecordSets;
							
							let responseData =
							{
								hostedZoneRecords: zoneRecords
							}

							entityos.invoke('util-end', responseData, '200');
						}
					);
				}
			}
		});

		//-- KMS | KEYS

		entityos.add(
		{
			name: 'app-process-aws-kms-keys',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
	
				let commandParams = {}

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
			
				const { KMSClient, ListKeysCommand} = require("@aws-sdk/client-kms");

				const kms = new KMSClient(infrastructureConfig);

				const command = new ListKeysCommand(commandParams);

				kms.send(command).then(function(response)
					{
						console.table(response.Keys)

						const keys = response.Keys;
						
						let responseData =
						{
							keys: keys
						}

						entityos.invoke('util-end', responseData, '200');
					}
				);
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-kms-key',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});

				const keyID = _.get(event, 'key.id');

				if (keyID == undefined)
				{
					entityos.invoke('util-end', 'No key.id set.', '400');
				}
				else
				{
					let commandParams =
					{
						KeyId: keyID
					}

					const infrastructureConfig = entityos.invoke('util-aws-get-config');
				
					const { KMSClient, DescribeKeyCommand } = require("@aws-sdk/client-kms");

					const kms = new KMSClient(infrastructureConfig);

					const command = new DescribeKeyCommand(commandParams);

					kms.send(command).then(function(response)
						{
							console.table(response.KeyMetadata)

							const key = response.KeyMetadata;
							
							let responseData =
							{
								key: key
							}

							entityos.invoke('util-end', responseData, '200');
						}
					);
				}
			}
		});

		/*
			Description: Adds a custom description for the key.
			KeyUsage:
				"ENCRYPT_DECRYPT": Standard encryption/decryption key (default).
				"SIGN_VERIFY": Used for digital signatures (asymmetric keys only).
			CustomerMasterKeySpec:
				"SYMMETRIC_DEFAULT": Standard symmetric key for encrypting data.
				"RSA_2048", "RSA_3072", "RSA_4096": Asymmetric RSA keys.
				"ECC_NIST_P256", "ECC_NIST_P384", etc.: Elliptic Curve keys.
		*/

		entityos.add(
		{
			name: 'app-process-aws-kms-key-create',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const keyID = _.get(event, 'key.id');
				
				let commandParams =
				{
					Description: _.get(event, 'key.description', 'Created by entityos-aws.'),
					KeyUsage: _.get(event, 'key.keyUsage', 'ENCRYPT_DECRYPT'),
					CustomerMasterKeySpec: _.get(event, 'key.customerMasterKeySpec', 'SYMMETRIC_DEFAULT')
				}

				if (_.get(event, 'key.tags') != undefined)
				{
						commandParams.Tags = _.get(event, 'key.tags')
				}

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
			
				const { KMSClient, CreateKeyCommand } = require("@aws-sdk/client-kms");

				const kms = new KMSClient(infrastructureConfig);

				const command = new CreateKeyCommand(commandParams);

				kms.send(command).then(function(response)
					{
						console.table(response.KeyMetadata)

						const key = response.KeyMetadata;
						
						let responseData =
						{
							key: key
						}

						entityos.invoke('util-end', responseData, '200');
					}
				);
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-kms-encrypt',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const keyID = _.get(event, 'key.id');
				const textToEncrypt = _.get(event, 'text.toEncrypt');
				
				let commandParams =
				{
					KeyId: keyID, // KMS Key ID or Key ARN
					Plaintext: Buffer.from(textToEncrypt, "utf-8"), // Convert string to Buffer
				}

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
			
				const { KMSClient, EncryptCommand } = require("@aws-sdk/client-kms");

				const kms = new KMSClient(infrastructureConfig);

				const command = new EncryptCommand(commandParams);

				kms.send(command).then(function(response)
					{
						console.table(Buffer.from(response.CiphertextBlob).toString("base64"))

						const dataBase64 = Buffer.from(response.CiphertextBlob).toString("base64");
						
						let responseData =
						{
							encryptedBase64: dataBase64
						}

						entityos.invoke('util-end', responseData, '200');
					}
				);
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-kms-decrypt',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const keyID = _.get(event, 'key.id');
				const textToDecrypt = _.get(event, 'text.toDecrypt');
				
				let commandParams =
				{
					KeyId: keyID, // KMS Key ID or Key ARN
					CiphertextBlob: Buffer.from(textToDecrypt, "base64"), // Convert string to Buffer
				}

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
			
				const { KMSClient, DecryptCommand } = require("@aws-sdk/client-kms");

				const kms = new KMSClient(infrastructureConfig);

				const command = new DecryptCommand(commandParams);

				kms.send(command).then(function(response)
					{
						const decryptedText = Buffer.from(response.Plaintext).toString("utf-8");
						
						let responseData =
						{
							decryptedText: decryptedText
						}

						entityos.invoke('util-end', responseData, '200');
					}
				);
			}
		});

		//-- BEDROCK (AI)

		entityos.add(
		{
			name: 'app-process-aws-bedrock-models',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
	
				let commandParams = {}

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
			
				const { BedrockClient, ListFoundationModelsCommand} = require("@aws-sdk/client-bedrock");

				const bedrock = new BedrockClient(infrastructureConfig);

				const command = new ListFoundationModelsCommand(commandParams);

				bedrock.send(command).then(function(response)
					{
						console.table(response.modelSummaries)

						const models = response.modelSummaries;
						
						let responseData =
						{
							models: models
						}

						entityos.invoke('util-end', responseData, '200');
					}
				);
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-bedrock-model-invoke',
			notes: 'Model access @ https://ap-southeast-2.console.aws.amazon.com/bedrock/home?region=ap-southeast-2#/modelaccess',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
	
				let commandParams = {
					modelId: _.get(event, 'model.id', 'amazon.titan-text-lite-v1'),
					contentType: "application/json",
					accept: "application/json",
					body: JSON.stringify({ inputText: _.get(event, 'model.inputText', 'Hello?') }),
				}

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
			
				const { BedrockRuntimeClient, InvokeModelCommand } = require("@aws-sdk/client-bedrock-runtime");

				const bedrockRuntime = new BedrockRuntimeClient(infrastructureConfig);

				const command = new InvokeModelCommand(commandParams);

				bedrockRuntime.send(command).then(function(response)
					{
						const _response = JSON.parse(Buffer.from(response.body).toString("utf-8"));
						console.table(_response.inputTextTokenCount)
						console.table(_response.results)
						
						let responseData = JSON.parse(Buffer.from(response.body).toString("utf-8"))
		
						entityos.invoke('util-end', responseData, '200');
					}
				);
			}
		});

		//-- IAM

		entityos.add(
		{
			name: 'app-process-aws-iam-role-create',
			notes: '',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const create = _.get(event, 'create');
				
				let commandParams = _.assign(
				{
					RoleName: _.get(create, 'rolename'),
					AssumeRolePolicyDocument: JSON.stringify(_.get(create, 'rolepolicydocument'))
				},
				_.get(create, 'options'));

				const infrastructureConfig = entityos.invoke('util-aws-get-config');			
				const { IAMClient, CreateRoleCommand, AttachRolePolicyCommand  } = require("@aws-sdk/client-iam");
				const iam = new IAMClient(infrastructureConfig);

				const command = new CreateRoleCommand(commandParams);

				iam.send(command).then(function(response)
				{
					const roleARN = response.Role.Arn;
					console.log(roleARN);

					entityos.set({scope: 'app-process-aws-iam-role-create', context: 'roleARN', value: roleARN});

					const commandParamsAttach = {
						RoleName: _.get(create, 'rolename'),
						PolicyArn: _.get(create, 'policyarn')
					};

					const attachCommand = new AttachRolePolicyCommand(commandParamsAttach);

					iam.send(attachCommand).then(function (response)
					{
						let responseData = response;
						delete responseData['$metadata'];

						const roleARN = entityos.get({scope: 'app-process-aws-iam-role-create', context: 'roleARN'});

						entityos.invoke('util-end', {roleARN: roleARN}, '200');
					})
				});
			}
		});
		
		//-- LAMBDA

		entityos.add(
		{
			name: 'app-process-aws-lambda-function-create',
			notes: '!! Set env variables',
			code: function ()
			{
				const event = entityos.get({ scope: '_event' });
				const create = _.get(event, 'create');

				if (create == undefined)
				{
					entityos.invoke('util-end', 'No create options set', '200');
				}
				else
				{
					const codeFolder = _.get(create, 'code.folder');
					const codeFilename = _.get(create, 'code.filename');

					const zipFilePath = codeFolder + '/' + codeFilename;

					const fs = require('fs');
					const functionCode = fs.readFileSync(zipFilePath);

					let commandParams = _.assign(
					{
						"Code": {
							ZipFile: functionCode
						},
					},
					_.get(create, 'options'));

					const infrastructureConfig = entityos.invoke('util-aws-get-config');

					const { LambdaClient, CreateFunctionCommand } = require('@aws-sdk/client-lambda');
					const lambda = new LambdaClient(infrastructureConfig);
					const command = new CreateFunctionCommand(commandParams);

					lambda.send(command).then(function (response)
					{
						let responseData = response;
						delete responseData['$metadata'];
						entityos.invoke('util-end', responseData, '200');
					})
					.catch(function (error)
					{
						entityos.invoke('util-end', 'Error creating Lambda function: ' + error.message, '500');
					});
				}
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-lambda-function-update',
			code: function ()
			{
				const event = entityos.get({ scope: '_event' });
				const update = _.get(event, 'update');

				if (update == undefined)
				{
					entityos.invoke('util-end', 'No update options set', '200');
				}
				else
				{
					const infrastructureConfig = entityos.invoke('util-aws-get-config');

					const { LambdaClient, UpdateFunctionCodeCommand, UpdateFunctionConfigurationCommand } = require('@aws-sdk/client-lambda');
					const lambda = new LambdaClient(infrastructureConfig);
					let commandParams = _.get(update, 'options');
					let command;

					const codeFilename = _.get(update, 'code.filename');

					if (codeFilename != undefined)
					{
						const codeFolder = _.get(update, 'code.folder');
						
						const zipFilePath = codeFolder + '/' + codeFilename;

						const fs = require('fs');
						const functionCode = fs.readFileSync(zipFilePath);

						commandParams = _.assign(commandParams,
						{
							ZipFile: functionCode
						});

						command = new UpdateFunctionCodeCommand(commandParams);
					}
					else
					{
						command = new UpdateFunctionConfigurationCommand(commandParams);
					}

					console.log(commandParams)

					lambda.send(command).then(function (response)
					{
						let responseData = response;
						delete responseData['$metadata'];

						entityos.invoke('util-end', responseData, '200');
					})
					.catch(function (error)
					{
						entityos.invoke('util-end', 'Error updating Lambda function: ' + error.message, '500');
					});
				}
			}
		});

		entityos.add(
		{
			name: 'app-process-aws-lambda-function-invoke',
			code: function ()
			{
				const event = entityos.get({ scope: '_event' });
				const invoke = _.get(event, 'invoke');

				if (invoke == undefined)
				{
					entityos.invoke('util-end', 'No invoke options set', '200');
				}
				else
				{
					let commandParams = _.assign(
					{
						"Payload": JSON.stringify(_.get(invoke, 'payload')),
					},
					_.get(invoke, 'options'));

					const infrastructureConfig = entityos.invoke('util-aws-get-config');

					const { LambdaClient, InvokeCommand } = require('@aws-sdk/client-lambda');
					const lambda = new LambdaClient(infrastructureConfig);

					const command = new InvokeCommand(commandParams);

					lambda.send(command).then(function (response)
					{
						response._payload = new TextDecoder().decode(response.Payload);
						response.data = JSON.parse(response._payload)
					
						entityos.invoke('util-end',
						{
							data: response.data
						},
						'200');
					})
					.catch(function (error)
					{
						entityos.invoke('util-end', 'Error invoking Lambda function: ' + error.message, '500');
					});
				}
			}
		});

		// EC2 IMAGE SHARING

		// Step 1: Share AMI with another account (run in SOURCE account)
		entityos.add(
		{
			name: 'app-process-aws-ec2-instance-image-share',
			notes: 'Share an AMI with another AWS account by modifying its launch permissions',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const imageID = _.get(event, 'image.id');
				const targetAccountIDs = _.get(event, 'target.accountIds');

				if (imageID == undefined || targetAccountIDs == undefined)
				{
					entityos.invoke('util-end', 'No image.id or target.accountIds set', '400');
				}
				else
				{
					const infrastructureConfig = entityos.invoke('util-aws-get-config');
					const { EC2Client, ModifyImageAttributeCommand } = require("@aws-sdk/client-ec2");
					const ec2 = new EC2Client(infrastructureConfig);

					const launchPermissions = targetAccountIDs.map(function(accountId)
					{
						return { UserId: accountId };
					});

					const commandParams =
					{
						ImageId: imageID,
						LaunchPermission:
						{
							Add: launchPermissions
						}
					};

					const command = new ModifyImageAttributeCommand(commandParams);

					ec2.send(command).then(function(response)
					{
						let responseData = response;
						delete responseData['$metadata'];
						responseData.message = 'AMI shared successfully';
						responseData.imageId = imageID;
						responseData.sharedWith = targetAccountIDs;
						entityos.invoke('util-end', responseData, '200');
					})
					.catch(function(error)
					{
						entityos.invoke('util-end', 'Error sharing AMI: ' + error.message, '500');
					});
				}
			}
		});

		// Step 2: Copy shared AMI into this account (run in DESTINATION account)
		entityos.add(
		{
			name: 'app-process-aws-ec2-instance-image-copy',
			notes: 'Copy an AMI from another account/region into this account',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const sourceImageID = _.get(event, 'source.imageId');
				const sourceRegion = _.get(event, 'source.region', 'ap-southeast-2');
				const destinationRegion = _.get(event, 'destination.region');
				const imageName = _.get(event, 'image.name');
				const imageDescription = _.get(event, 'image.description', '');
				const encrypted = _.get(event, 'encrypted', true);
				const kmsKeyId = _.get(event, 'kmsKeyId');

				if (sourceImageID == undefined)
				{
				entityos.invoke('util-end', 'No source.imageId set', '400');
				}
				else
				{
				const infrastructureConfig = entityos.invoke('util-aws-get-config');

				if (destinationRegion != undefined)
				{
					infrastructureConfig.region = destinationRegion;
				}

				const { EC2Client, CopyImageCommand } = require("@aws-sdk/client-ec2");
				const ec2 = new EC2Client(infrastructureConfig);

				let commandParams = {
					SourceImageId: sourceImageID,
					SourceRegion: sourceRegion,
					Name: imageName || 'copy-' + sourceImageID + '-' + moment().format('YYYY-MM-DD-HH-mm'),
					Description: imageDescription,
					Encrypted: encrypted
				};

				if (kmsKeyId != undefined)
				{
					commandParams.KmsKeyId = kmsKeyId;
				}

				const command = new CopyImageCommand(commandParams);

				ec2.send(command).then(function(response)
				{
					let responseData = {
					sourceImageId: sourceImageID,
					newImageId: response.ImageId,
					message: 'AMI copy initiated'
					};
					entityos.invoke('util-end', responseData, '200');
				})
				.catch(function(error)
				{
					entityos.invoke('util-end', 'Error copying AMI: ' + error.message, '500');
				});
				}
			}
		});

		// Optional: Remove share permissions (run in SOURCE account)
		entityos.add(
		{
			name: 'app-process-aws-ec2-instance-image-unshare',
			notes: 'Remove AMI share permissions from another AWS account',
			code: function ()
			{
				const event = entityos.get({scope: '_event'});
				const imageID = _.get(event, 'image.id');
				const targetAccountIDs = _.get(event, 'target.accountIds');

				if (imageID == undefined || targetAccountIDs == undefined)
				{
				entityos.invoke('util-end', 'No image.id or target.accountIds set', '400');
				}
				else
				{
				const infrastructureConfig = entityos.invoke('util-aws-get-config');
				const { EC2Client, ModifyImageAttributeCommand } = require("@aws-sdk/client-ec2");
				const ec2 = new EC2Client(infrastructureConfig);

				const launchPermissions = targetAccountIDs.map(function(accountId)
				{
					return { UserId: accountId };
				});

				const commandParams = {
					ImageId: imageID,
					LaunchPermission: {
					Remove: launchPermissions
					}
				};

				const command = new ModifyImageAttributeCommand(commandParams);

				ec2.send(command).then(function(response)
				{
					let responseData = response;
					delete responseData['$metadata'];
					responseData.message = 'AMI share removed';
					responseData.imageId = imageID;
					responseData.removedFrom = targetAccountIDs;
					entityos.invoke('util-end', responseData, '200');
				})
				.catch(function(error)
				{
					entityos.invoke('util-end', 'Error unsharing AMI: ' + error.message, '500');
				});
				}
			}
		});
	}
}